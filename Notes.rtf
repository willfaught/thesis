{\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf290
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww15340\viewh12720\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural

\f0\fs24 \cf0 EL e^L =~ e^L?\
LE e^E =~ e^E?\
\
(K 0) (LE \\omega)\
(K 0) (EL \\omega)\
\
((LE K) I) \\omega\
\
Potential problems: diverge, error (if in model!)\
\
L's K is NOT E's K, it's equivalent!\
L's K doesn't use 2nd arg, no diverge.\
LE K (L's K) MUST NOT cause diverge!\
LE K is an L fct!\
\
Changing which exps are evaluated changes what fcts compute\
Restricting eval's exps (lazy) restricts the places where exps diverge\
\
Interop ought not to change what functions compute\
Converted functions ought not to diverge where they did not before, and vice versa\
Assumed types add arg/result checks and conversions, but do not change fcts\
\
Restricted eval exps must be mirrored in other langs to preserve fct behavior\
More strict veal can cause new behavior: diverge, errors\
\
Lazy behavior is superset of eager behavior, more expressible that does not change fct behavior\
\
Eager fct converted to lazy that diverges: K\
	Illustrates need for force/unforce evaluation cxts\
\
Lazy fct translated to eager that diverges: Y\
	Cannot mechanically translate terms: Y combinator diverges\
\
No lazy fct exists that, when converted to eager without extra force points, computes differently/diverges\
\
Labels can use tyvars after all, since labels are well-formed only if the underlying type is well-formed, the mark is irrelevant, can be tyvar!!\
\
==\
\
SOME VALUES EXPRESSIBLE IN LAZY AND NOT EAGER ONES\
\
Can simulate recursive lazy values in eager languages with thunks and forcing.\
\
fix \\ x : [N] . cons 1 x\
Lazy: it's a value\
Eager: diverges\
\
fix \\ f : [N] -> [N] . \\ x : [N] . cons 1 f\
Eager: works, value, must force thunks\
\
==\
\
REDUCTION RULES PUTTING TYPE FROM ONE LANG IN ANOTHER\
\
Okay since can't have tyvars inside, otherwise wouldn't be reducing or ill-typed. Idea being that types are coerced if not lang-specific.  H and M have their own list type, and coercion turns one into the other.\
\
See the red rules for importation of forall types for type abstractions, e.g.:\
\
hm (Ax.t) (\\\\x.e) -> \\\\x.hm t e\
\
The subsequent type application's type substitution performs type coercion when substituting the type application argument into ML's exp.\
\
==\
\
FIXED POINT OPERATIONS\
\
Operand types are the same for H and M (t->t) because the same definition works for both H and M, it doesn't diverge in M because application isn't used to substitute.\
\
==\
\
STRIPPING LABELS\
\
Reduction rules must strip labels because the expressions the underlying types are put into are expected to have the underlying types.  If not, the outer expression would be ill-typed.  An alternative would be to strip the labels in the typing rules, like they are for guards.\
\
==\
\
WHY LABELS ON H/M IMPORTATIONS ARE NEEDED\
\
For the matching labels mechanism. Otherwise, not needed.\
\
==\
\
TYVARS AS LABELS IS SAFE\
\
Label confusion not possible because no free tyvars.  If nested forall, outer forall will go away when reducing inner forall.  Reduction of HS/MS is referentially transparent.\
\
==\
\
LUMP TYPES\
\
The only H and M expressions that can have lump types, as in:\
\
HM L ?\
\
MH L ?\
\
are Scheme importation guards, e.g. HS or MS:\
\
HM L (MS L 0)\
\
Anything else would not be well-typed, so you don't have to account for it in the op seem.\
\
==\
\
TYPE LABEL USE\
\
Eval contexts guarantee that type labels created by applying an imported type abstraction from Scheme cannot be nested, so the type label removal substitution notation t[ti/ti.x] can mean to remove all type labels. Also why the Parametricity Violated red rule can strip the label. BUT THE PROGRAMMER CAN WRITE THEM NESTED!\
\
==\
\
LABELS STRIPPED ON HS AND MS GUARD REDUCTIONS\
\
Because the typing rules for the expressions that are the results of these reduction rules do not account for labels, and for these reductions to be useful to outer expressions that do not anticipate label types, the types must be stripped.  This happens for any reduction which produces an expression that contains a type that originates from the guard type.\
\
==\
\
VARIABLE LANGUAGE SUPERSCRIPTS\
\
MUST add language subscripts to variables 'x' and type variables 'X' because otherwise \\x:N.(N^HM x) and \\\\X.^(X->N)HM (\\x:X.0) are well typed! Explaining that vars/tyvars separate between langs and losing subscripts will make syntax unreadable, not enough fonts to distinguish.\
\
==\
\
LABEL AND LUMP TYPES ONLY FOR INTEROP\
\
Uses elsewhere by the programmer are errors.  This allows me to not address the guard reduction cases for these types, which is beyond the scope of this paper.\
\
As such, HS L v uses 'v' because L is only used for the importation of type abstractions into Scheme, which, if the type variable is ever used and the inner expression is well-typed, should yield a function at some point, and since function arguments are unforced, the only expressions in HS L ? would be unforced Scheme values 'v^s'.}