{\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf290
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww15340\viewh12720\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural

\f0\fs24 \cf0 EL e^L =~ e^L?\
LE e^E =~ e^E?\
\
(K 0) (LE \\omega)\
(K 0) (EL \\omega)\
\
((LE K) I) \\omega\
\
Potential problems: diverge, error (if in model!)\
\
L's K is NOT E's K, it's equivalent!\
L's K doesn't use 2nd arg, no diverge.\
LE K (L's K) MUST NOT cause diverge!\
LE K is an L fct!\
\
Changing which exps are evaluated changes what fcts compute\
Restricting eval's exps (lazy) restricts the places where exps diverge\
\
Interop ought not to change what functions compute\
Converted functions ought not to diverge where they did not before, and vice versa\
Assumed types add arg/result checks and conversions, but do not change fcts\
\
Restricted eval exps must be mirrored in other langs to preserve fct behavior\
More strict veal can cause new behavior: diverge, errors\
\
Lazy behavior is superset of eager behavior, more expressible that does not change fct behavior\
\
Eager fct converted to lazy that diverges: K\
	Illustrates need for force/unforce evaluation cxts\
\
Lazy fct translated to eager that diverges: Y\
	Cannot mechanically translate terms: Y combinator diverges\
\
No lazy fct exists that, when converted to eager without extra force points, computes differently/diverges\
\
Labels can use tyvars after all, since labels are well-formed only if the underlying type is well-formed, the mark is irrelevant, can be tyvar!!\
\
Change type non-terminal T to lower-case t.\
\
==\
\
SOME VALUES EXPRESSIBLE IN LAZY AND NOT EAGER ONES\
\
Can simulate recursive lazy values in eager languages with thunks and forcing.\
\
fix \\ x : [N] . cons 1 x\
Lazy: it's a value\
Eager: diverges\
\
fix \\ f : [N] -> [N] . \\ x : [N] . cons 1 f\
Eager: works, value, must force thunks\
\
==\
\
REDUCTION RULES PUTTING TYPE FROM ONE LANG IN ANOTHER\
\
Okay since can't have tyvars inside, otherwise wouldn't be reducing or ill-typed. Idea being that types are coerced if not lang-specific.  H and M have their own list type, and coercion turns one into the other.\
\
See the red rules for importation of forall types for type abstractions, e.g.:\
\
hm (Ax.t) (\\\\x.e) -> \\\\x.hm t e\
\
The subsequent type application's type substitution performs type coercion when substituting the type application argument into ML's exp.\
\
==\
\
FIXED POINT OPERATIONS\
\
Operand types are the same for H and M (t->t) because the same definition works for both H and M, it doesn't diverge in M because application isn't used to substitute.\
\
==\
\
STRIPPING LABELS\
\
Reduction rules must strip labels because the expressions the underlying types are put into are expected to have the underlying types.  If not, the outer expression would be ill-typed.  An alternative would be to strip the labels in the typing rules, like they are for guards.\
\
==\
\
WHY LABELS ON H/M IMPORTATIONS ARE NEEDED\
\
For the matching labels mechanism. Otherwise, not needed.\
\
==\
\
TYVARS AS LABELS IS SAFE\
\
Label confusion not possible because no free tyvars.  If nested forall, outer forall will go away when reducing inner forall.  Reduction of HS/MS is referentially transparent.\
\
==\
\
LUMP TYPES\
\
The only H and M expressions that can have lump types, as in:\
\
HM L ?\
\
MH L ?\
\
are Scheme importation guards, e.g. HS or MS:\
\
HM L (MS L 0)\
\
Anything else would not be well-typed, so you don't have to account for it in the op seem.\
\
==\
\
TYPE LABEL USE\
\
Eval contexts guarantee that type labels created by applying an imported type abstraction from Scheme cannot be nested, so the type label removal substitution notation t[ti/ti.x] can mean to remove all type labels. Also why the Parametricity Violated red rule can strip the label. BUT THE PROGRAMMER CAN WRITE THEM NESTED!\
\
}