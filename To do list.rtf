{\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf320
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww16060\viewh12680\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural

\f0\fs24 \cf0 To do list\
\
- Use 'forall type' consistently.  No 'universally quantified', 'universal', 'polymorphic', etc.\
- H/M progress theorem: Case 1.7 (MH) is wrong, each case assumes the exp is in the hole, so use Fig. 2.14. Check other cases/theorems! PROOF IS WRONG ABOUT FORCED/UNFORCED VALUE PROGRESS!\
- Incorporate Clements' old email feedback\
- Get parametricity def from Pierce\
- Note that you kept the fix operand type the same in your summary email of the final draft\
- Recheck proof for forced/unforced value usage - see ML app in progress!!!\
- Revise whole paper to use the new syntax\
- Ask Clements about conversion of type abstractions between H and M, specifically about how to turn H types into M types and vice versa\
- Point out to Clements all the model changes: label syntax, language symbol position, dropped HS/MS import forall forced values, separate H/M types, etc.\
- Ask Clements if okay to omit parts of M proof for brevity where identical to H?\
==\
- Ensure nested labels cannot happen, then update the note\
- Lang letters are part of the var, including variables and type variables, must use fresh vars where appropriate.  Check all uses.\
- Check overfull hboxes in figures, etc.\
- Types are equal up to alpha equivalence\
- Type substitution is amended to unbrand conversion schemes where necessary when substituting for type variables\
- If types are equal up to alpha equivalence, then make sure to use equality instead of the same variable (e.g. typing rules, red rules)\
- Is the H/M var case for the inversion lemma correct (using set membership notation)?\
- See Pierce TAPL p. 94 for inversion lemma explanation (current is wrong)\
- Ask Clements about ps proof hypothesis: if unforced value or e->e' or e->Error in the MH/SH cases, since they are always unforced values, but sometimes reduce.\
- Mention to Clements that I omit many ML and Scheme cases that are similar to Haskell cases for brevity.\
- The MH/SH cases in the ps proof.\
}