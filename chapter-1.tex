\chapter{Introduction}

Software components comprise various programming languages, interfaces, and execution platforms.  Components of homogeneous configurations of these and other properties cooperate more easily than components of heterogeneous configurations interoperate.  This relative ease encourages components to be redefined in common configurations, rather than reusing existing solutions to problems from less common configurations.  Components of different languages interoperate by exchanging data across boundaries between their languages.  Language boundaries convert data from one form to another and ensure that interoperation does not violate any language property.  Language incompatibilities complicate interoperation and arise where equivalent forms of data do not exist or where interoperation would violate a language property.  This paper explores and resolves three such incompatibilities with a model of computation, proves its type soundness, and describes an implementation of it.

\section{Evaluation Strategies}

The first incompatibility is evaluation strategies.  Evaluation strategies determine the order in which languages evaluate expressions.  Eager evaluation reduces expressions regardless of necessity, and lazy evaluation reduces expressions only where necessary.  Lazy languages --- languages that use lazy evaluation --- can construct infinite streams as lists because they do not evaluate list elements when lists are constructed, but eager languages cannot because they do.  Not all lazy lists --- lists in lazy languages --- can be converted to eager lists.  Instead, elements of lazy lists can be converted when accessed by eager languages if they are not lazy lists too.

\section{Type Systems}

The second incompatibility is type systems.  Static type systems calculate and validate the types of expressions before run time and guarantee that well-typed programs will not encounter type errors during run time.  Run-time type calculations or validations are unnecessary.  Dynamic type systems do not calculate or validate the types of expressions.  Programs can use predicates to calculate the kinds of values during run time.

In the model, components exchange a common set of values.

Statically-typed languages --- languages that use static type systems --- must verify that the actual type of data received from a server matches their expected type.  Mismatched types may cause type errors during run time, which statically-typed languages cannot detect because they do not calculate or validate types during run time.  If data was sent from statically-typed languages, their actual type can be calculated and validated before run time.  If data was sent from dynamically-typed languages, their actual type cannot be calculated until run time, except functions.  Since dynamically-typed functions can produce results of various types, and determining function behavior is undecidable \cite{blume04}, equivalent types for these functions cannot be reliably calculated.  Since the types of dynamically-typed functions cannot be reliably calculated at boundaries, those functions are wrapped in contracts \cite{findler02} that calculate and validate the types of their arguments and results during run time.

\section{Parametricity}

The third incompatibility is parametricity.  Parametricity ensures that parametric polymorphic functions from statically-typed languages behave the same regardless of the types and values of their arguments, and that those functions with variable result types produce as their results an argument with the same variable type.  Dynamically-typed functions can use type predicates and conditions to determine their behavior by the types and values of their arguments.  If dynamically-typed functions are used as parametric polymorphic functions in languages that support parametricity, they can break parametricity.  Arguments for these functions must be wrapped such that type predicates and conditions cannot examine them.

The languages in the model must be able to express programs in which the aforementioned three incompatibilities arise.  Haskell, ML, and Scheme each possess a unique combination of properties that together are sufficient for this purpose.  Haskell and ML use static type systems and support parametricity.  ML and Scheme use eager evaluation.  Haskell uses lazy evaluation.  Scheme uses a dynamic type system.  Any more languages would uselessly complicate the model.

The rest of the paper is organized as follows: Chapter 2 defines the model of computation.  Chapter 3 proves the type soundness of the model.  Chapter 4 describes an implementation of the model.  Chapter 5 discusses related work.  Chapter 6 discusses future work.  Chapter 7 discusses the conclusions.