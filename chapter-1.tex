\chapter{Introduction}

Software components written in different programming languages can cooperate through interoperation.  Interoperation is a client-server interaction concerning the reuse of server resources by clients.  Servers send data and clients receive data across a boundary between their languages that converts the data into a form understandable to clients.  The data exchange must not violate the type system or any property of either language for interoperation to be useful.  Differences between languages---incompatibilities---complicate interoperation, especially where equivalent forms of data do not exist.  This paper explores and resolves three such incompatibilities with a model of computation, gives a thorough proof of its type soundness, and describes an implementation of it.

The first incompatibility is the type system.  Static type systems calculate and validate the types of expressions before run time.  They guarantee that well-typed programs will not encounter type errors during run time.  Run-time type calculations and validations are unnecessary.  Dynamic type systems calculate and validate the types of expressions during run time to detect type errors.  Programs can explicitly calculate the types of expressions with type predicates and report type errors with an error mechanism.  If they detect a type error, they report it and terminate the computation.

Statically-typed languages---languages that use static type systems---must verify that the actual type of data received from a server matches their expected type.  Mismatched types may cause type errors during run time, which statically-typed languages cannot detect because they do not calculate or validate types during run time.  If data was sent from statically-typed languages, their actual type can be calculated and validated before run time.  If data was sent from dynamically-typed languages, their actual type cannot be calculated until run time, except functions.  Since dynamically-typed functions can produce results of various types, and determining function behavior is undecidable \cite{blume04}, equivalent types for these functions cannot be reliably calculated.  Since the types of dynamically-typed functions cannot be reliably calculated at boundaries, those functions are wrapped in contracts \cite{findler02} that calculate and validate the types of their arguments and results during run time.

The second incompatibility is the support for parametricity.  Parametricity ensures that parametric polymorphic functions from statically-typed languages behave the same regardless of the types and values of their arguments, and that those functions with variable result types produce as their results an argument with the same variable type.  Dynamically-typed functions can use type predicates and conditions to determine their behavior by the types and values of their arguments.  If dynamically-typed functions are used as parametric polymorphic functions in languages that support parametricity, they can break parametricity.  Arguments for these functions must be wrapped such that type predicates and conditions cannot examine them.

The third incompatibility is the evaluation strategy.  Evaluation strategies determine the order in which languages evaluate expressions.  Eager evaluation reduces expressions regardless of necessity, and lazy evaluation reduces expressions only where necessary.  Lazy languages---languages using lazy evaluation---can construct infinite streams as lists because they do not evaluate list elements when lists are constructed, but eager languages cannot because they do.  Therefore there are some lazy lists---lists in lazy languages---for which there are no equivalent eager lists.  Since lazy lists cannot be mechanically converted to eager lists, lazy lists cannot cross to eager languages.  Instead, elements of lazy lists can cross when accessed by eager languages if they are not lazy lists too.

The languages in the model must be able to express programs in which the aforementioned three incompatibilities arise.  Haskell, ML, and Scheme each possess a unique combination of properties that together are sufficient for this purpose.  Haskell and ML use static type systems and support parametricity.  ML and Scheme use eager evaluation.  Haskell uses lazy evaluation.  Scheme uses a dynamic type system.  Any more languages would uselessly complicate the model.

The rest of the paper is organized as follows: Chapter 2 defines the model of computation.  Chapter 3 proves the type soundness of the model.  Chapter 4 describes an implementation of the model.  Chapter 5 discusses related work.  Chapter 6 discusses future work.  Chapter 7 discusses the conclusions.