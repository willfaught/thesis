\chapter{Introduction}

Software components written in different programming languages can cooperate through interoperation.  Interoperation is a client-server interaction concerning the reuse of server resources by clients.  Clients and servers exchange data across a boundary between their languages that converts data into a form understandable to the receiver.  The data exchange must not violate the type system or any property of either language for interoperation to be useful.  Differences between languages---incompatibilities---complicate interoperation, especially where equivalent forms of data do not exist.  This paper explores and resolves three such incompatibilities with a model of computation, gives a thorough proof of its type soundness, and describes an implementation of it.

The first incompatibility is the type system.  Static type systems calculate and validate the types of expressions before run time.  They guarantee that well-typed programs will not encounter type errors during run time.  Run-time type calculations and validations are unnecessary and reduce performance.  Dynamic type systems calculate and validate the types of expressions during run time to detect type errors.  Programs can explicitly calculate the types of expressions with type predicates and report type errors with an error mechanism.  If they detect a type error, they report it and terminate the computation.

Statically-typed languages that receive data must verify that the actual types of the data match the types they expected.  Mismatched types may cause type errors, which statically-typed languages cannot detect because they do not check internal types during run time.  If a statically-typed language sent the data, the type of the data is immediately available because the language can calculate its type.  If a dynamically-typed language sent the data, it can reliably calculate the types of all data except functions.  Since functions in dynamically-typed languages can produce results of various types and determining function behavior is undecidable \cite{blume04}, function types cannot be reliably calculated.  Therefore dynamically-typed languages cannot reliably calculate the types of functions at boundaries.  Instead, functions are wrapped in contracts \cite{findler02} that check the types of their arguments and results and report type errors during run time.

The second incompatibility is the preservation of parametricity.  Parametricity guarantees that parametric polymorphic functions in statically-typed languages behave the same regardless of the types and values of their arguments.  It can ease understanding of function behavior and simplify testing.  Breaking parametricity violates assumptions made by programmers.  If functions in dynamically-typed languages are used as parametric polymorphic functions in languages that preserve parametricity, they must be prevented from using type predicates and conditions to determine their behavior by the types and values of their arguments and thereby break parametricity.  The types and values of arguments for such functions are concealed to preserve parametricity.

The third incompatibility is the evaluation strategy.  Evaluation strategies determine the order in which languages evaluate expressions.  Eager evaluation evaluates a function argument before applying the function to it.  Lazy evaluation does not evaluate a function argument before applying the function to it.  Lazy languages---languages using lazy evaluation---can construct infinite streams as lists because list elements are not evaluated until needed.  Eager languages cannot construct infinite streams as lists because list elements are evaluated when lists are constructed.  Therefore there are some lazy lists---lists in lazy languages---for which there are no equivalent eager lists.  Since lazy lists cannot be mechanically converted to eager lists, lazy lists do not cross boundaries to eager languages.  Instead, if the head or tail of a lazy list is accessed by an eager language, it replaces the list and can cross to the eager language if it is not a lazy list.

The languages in the model must be able to express programs in which the aforementioned three incompatibilities arise.  Haskell, ML, and Scheme each possess a unique combination of properties that together are sufficient for the purpose in mind.  Haskell and ML use static type systems with parametric polymorphism and preserve parametricity.  ML and Scheme use eager evaluation.  Haskell uses lazy evaluation.  Scheme uses a dynamic type system.  Any more languages would uselessly complicate the model.

The rest of the paper is organized as follows: Chapter 2 defines the model of computation.  Chapter 3 proves the type soundness of the model.  Chapter 4 describes an implementation of the model.  Chapter 5 discusses related work.  Chapter 6 discusses future work.  Chapter 7 discusses the conclusions.