\section{Introduction}

The complexities of software interoperation in part engender the proverbial reinvention of the wheel. Programmers forgo preexisting solutions to problems where interoperation proves too cumbersome; they reimplement software components, rather than reuse them. Disparate programming language features complicate the conversion of values exchanged between components of different languages. Resolving language incompatibilities transparently at boundaries between component languages facilitates interoperation by unburdening programmers. This paper presents a model of computation that resolves incompatible evaluation strategies.

Call-by-name and call-by-value evaluation strategies use orders of evaluation that take opposite approaches. Call-by-name only evaluates expressions needed for primitive operations, and call-by-value evaluates all expressions. As such, call-by-name evaluates a subset of the expressions that call-by-value does. In other words, the set of call-by-name strictness points is a subset of that of call-by-value. The difference between these two sets is the set of strictness points that are incompatible for interoperation between call-by-name and call-by-value languages.

Interoperation requires preserving these strictness points for each evaluation strategy, even after a call-by-name value is converted to a call-by-value value. Otherwise, expressions may be evaluated where they were not before and cause errors or diverge. This means deferring the evaluation of converted call-by-name expressions in these incompatible points using a dual notion of values and evaluation contexts in call-by-value languages that handles both call-by-value values and converted call-by-name expressions, called \emph{forced} and \emph{unforced} values and evaluation contexts.