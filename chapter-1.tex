\chapter{Introduction}

Programming language interoperation is the cooperation of software components written in different languages.  Components cooperate by exchanging data across a boundary between their languages.  A boundary converts data from the form understandable by the sending language to a form understandable by the receiving language.  A set of $n$ interoperable languages requires $n\times(n-1)$ boundaries.

Language incompatibilities complicate the process of interoperation.  One such incompatibility is type systems.  Static type systems calculate and validate the types of expressions before run time.  They guarantee that well-typed programs will not encounter type errors during run time.  Run-time type calculations and validations are unnecessary and reduce performance.  Dynamic type systems calculate and validate the types of expressions during run time to detect type errors.  Programs can explicitly calculate the types of expressions with type predicates and report type errors with an error mechanism.  If they detect a type error, they report it and terminate the computation.

Statically-typed languages that receive data must verify that the actual types of the data match the types they expected.  Mismatched types may cause type errors, which statically-typed languages cannot detect because they do not check internal types during run time.  If a statically-typed language sent the data, the type of the data is immediately available because the language can calculate its type.  If a dynamically-typed language sent the data, it can reliably calculate the types of all data except functions.  Since functions in dynamically-typed languages can produce results of various types and determining function behavior is undecidable \cite{blume04}, function types cannot be reliably calculated.  Therefore dynamically-typed languages cannot reliably calculate the types of functions at boundaries.  Instead, functions are wrapped in contracts \cite{findler02} that check the types of their arguments and results and report type errors during run time.

A second incompatibility is the preservation of parametricity.  Parametricity is a language quality which guarantees that parametrically polymorphic functions behave the same regardless of argument types.  It can ease understanding of function behavior and simplify testing.  Breaking parametricity violates assumptions made by the programmer and other code.  Data passed to functions that may break parametricity are wrapped in such a way to appear inscrutable to type predicates, thereby rendering parametricity-breaking behavior impossible.

A third incompatibility is evaluation strategy.  An evaluation strategy determines the order in which expressions are evaluated, most generally when function arguments are evaluated.  Strict evaluation evaluates a function argument before it is substituted for the function parameter.  Lazy evaluation substitutes a function argument for the function parameter without evaluating it.  If the argument is used within the body of the function, it is then evaluated.  Lazy evaluation enables the easy definition of infinite streams using lists, where the list tail is not evaluated until it is used.  Under strict evaluation, every list element is evaluated even if they are not used.  Therefore an infinite list passed from a lazy language to a strict language cannot be converted to an equivalent form because all its elements will be evaluated, which will loop forever because the list is infinite.  Instead, the list is not converted, but passed along wrapped in a container until the strict language needs to access the head or tail, in which case the appropriate item is removed.  If the removed item is itself another infinite list, it too is kept wrapped in a container until its head or tail are needed by the strict language.

Three languages were chosen to investigate solutions to these three incompatibilities.  Haskell and ML use static type systems and preserve parametricity.  ML and Scheme use strict evaluation.  Haskell uses lazy evaluation.  Scheme uses a dynamic type system.  All three languages have higher-order functions.  A system of interoperation for these languages allows the language incompatibilities discussed above to arise.  

The rest of the paper is organized as follows: Chapter 2 defines the model of computation.  Chapter 3 proves the type soundness of the model.  Chapter 4 describes an implementation of the model.  Chapter 5 discusses related work.  Chapter 6 discusses future work.  Chapter 7 discusses the thesis conclusions.