Programming language interoperation is the cooperation of software components written in different languages.  Components cooperate by exchanging data across a boundary between languages.  The boundary converts data from a form understandable by the sending language to a form understandable by the receiving language.  A form of boundary, called an interface bridge, is a two-way map between languages of client and server components.  A set of n interoperable languages requires $n\times(n-1)$ maps to interoperate.

Language incompatibilities can arise when components exchange data.  One such incompatibility is type systems.  Static type systems check the types of terms at compile time to determine if a type error can occur during run time.  If an error is detected, a program is prevented from being compiled.  In this way static type systems guarantee that no type errors will occur at run time, so there is no need to perform type checks at run time.  Dynamic type systems do not check the types of terms at compile time.  Instead, they insert code that checks types at run time to detect type errors and terminate the computation if one arises.

When data passes to a component of a statically typed language, its type must be checked at the boundary to ensure it matches its expected type.  Otherwise, a type error caused by the type mismatch would not be detected at run time because statically typed languages do not perform type checks at run time.  If the data comes from a statically typed language, the type of the data is immediately available.  If the data comes from a dynamically typed language, the language must use its type predicates to determine the type of the data.  In the case of a function, type predicates cannot reliably determine its type.  Functions in dynamically typed languages can consume various types of arguments and produce various types of results.  Determining which type of result a function will produce is equivalent to determining its behavior, which is undecidable.  Therefore the types of functions of dynamically typed languages cannot be reliably determined at the boundary.  Instead, functions are wrapped in contracts that check the types of its arguments and results and signal the occurrence of type errors at run time.

A second incompatibility is the preservation of parametricity.  Parametricity is a language quality which guarantees that parametrically polymorphic functions behave the same regardless of argument types.  It can ease understanding of function behavior and simplify testing.  Breaking parametricity violates assumptions made by the programmer and other code.  Data passed to functions that may break parametricity are wrapped in such a way to appear inscrutable to type predicates, thereby rendering parametricity-breaking behavior impossible.

A third incompatibility is evaluation strategy.  An evaluation strategy determines the order in which expressions are evaluated, most generally when function arguments are evaluated.  Strict evaluation evaluates a function argument before it is substituted for the function parameter.  Lazy evaluation substitutes a function argument for the function parameter without evaluating it.  If the argument is used within the body of the function, it is then evaluated.  Lazy evaluation enables the easy definition of infinite streams using lists, where the list tail is not evaluated until it is used.  Under strict evaluation, every list element is evaluated even if they are not used.  Therefore an infinite list passed from a lazy language to a strict language cannot be converted to an equivalent form because all its elements will be evaluated, which will loop forever because the list is infinite.  Instead, the list is not converted, but passed along wrapped in a container until the strict language needs to access the head or tail, in which case the appropriate item is removed.  If the removed item is itself another infinite list, it too is kept wrapped in a container until its head or tail are needed by the strict language.

Three languages were chosen to investigate solutions to these three incompatibilities.  Haskell and ML use static type systems and preserve parametricity.  ML and Scheme use strict evaluation.  Haskell uses lazy evaluation.  Scheme uses a dynamic type system.  All three languages have higher-order functions.  A system of interoperation for these languages allows the language incompatibilities discussed above to arise.  

The rest of the paper is organized as follows: [TODO]