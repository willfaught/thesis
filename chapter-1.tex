\chapter{Introduction}

Software components comprise various programming languages, interfaces, and execution platforms.  Components of homogeneous configurations of these and other properties cooperate more easily than components of heterogeneous configurations interoperate.  This relative ease encourages components to be redefined in common configurations, rather than reusing existing solutions to problems from less common configurations.  Components of different languages interoperate by exchanging data across boundaries between their languages.  Language boundaries convert data from one form to another and ensure that interoperation does not violate any language property.  Language incompatibilities complicate interoperation and arise where equivalent forms of data do not exist or where interoperation would violate a language property.  This paper explores and resolves three such incompatibilities with a model of computation, proves its type soundness, and describes an implementation of it.

The first incompatibility is evaluation strategies.  Evaluation strategies determine the order in which languages evaluate expressions.  Eager evaluation reduces expressions regardless of necessity, and lazy evaluation reduces expressions only where necessary.  Lazy languages --- languages that use lazy evaluation --- can construct infinite streams as lists because they do not evaluate list elements when lists are constructed, but eager languages cannot because they do.  Lazy lists --- lists in lazy languages --- are equivalent to eager lists if the sequences of elements are equivalent.  Since there exist lazy lists for which no equivalent eager lists exist, lazy lists are not converted to eager lists.  Instead, elements of lazy lists are converted when accessed by eager languages if they are not lazy lists too.

The second incompatibility is type systems.  Static type systems calculate and validate the types of expressions before run time and guarantee that well-typed programs will not encounter type errors during run time.  Run-time type calculations and validations are unnecessary.  Dynamic type systems validate values during run time and do not calculate or validate the types of expressions.  Programs can use value predicates to calculate the kinds of values during run time.  The languages in the model will use and exchange a common set of values.  Statically-typed languages --- languages that use static type systems --- must verify at boundaries that the expected types of received values match their actual types.  Mismatched expected and actual types could cause type errors during run time and violate type soundness.  The actual types of values to be sent from statically-typed languages can be calculated and validated before run time.  Ad-hoc polymorphism in dynamically-typed languages enables argument types to determine polymorphic function behavior.  Since determining function behavior is undecidable \cite{blume04}, equivalent types for these functions cannot be reliably calculated.  Instead, they are wrapped in contracts \cite{findler02} that defer the calculations of their argument and result types until they are used during run time.

The third incompatibility is parametricity.  Parametricity constrains the kinds of parametric polymorphic functions that are well-typed.  Parametric polymorphism in statically-typed languages enables the types of expressions to be parameterized by type variables and type abstractions and then instantiated by applying type abstractions to types.  Parametricity ensures that parametric polymorphic functions behave the same regardless of the types and values of their arguments, and that polymorphic results correspond to polymorphic arguments of the same type variables.  Functions from dynamically-typed languages can violate parametricity with value predicates and conditions or by evaluating to results of the wrong type variables.  Languages with parametricity that use these functions as parametric polymorphic functions risk violating their parametricity.  Arguments for these functions must be obscured such that value predicates and conditions cannot examine them and annotated with their type variables such that the type variables of polymorphic results can be validated.

The languages in the model must be able to express programs in which the aforementioned three incompatibilities arise.  Haskell, ML, and Scheme each possess a unique combination of properties that together are sufficient for this purpose: Haskell and ML use static type systems and have parametricity, ML and Scheme use eager evaluation, Haskell uses lazy evaluation, and Scheme uses a dynamic type system.

The rest of the paper is organized as follows: Chapter 2 defines the model of computation, Chapter 3 proves the type soundness of the model, Chapter 4 describes an implementation of the model, Chapter 5 discusses related work, Chapter 6 discusses future work, and Chapter 7 discusses the conclusions.