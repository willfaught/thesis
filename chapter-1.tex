\section{Introduction}

The complexities of software interoperation in part engender the proverbial reinvention of the wheel.  Programmers forgo preexisting solutions to problems where interoperation proves too cumbersome; they reimplement software components, rather than reuse them.  Disparate programming language features complicate the conversion of values exchanged between components of different languages.  Resolving language incompatibilities transparently at boundaries between component languages facilitates interoperation by unburdening programmers.  This paper explores and resolves two such incompatibilities with a model of computation and then proves its type soundness and describes its implementation.

The first incompatibility is type systems.  Static type systems calculate and validate the types of expressions before run time, thereby ensuring that well-typed programs do not encounter type errors during run time.  Dynamic type systems detect invalid operations on values using value predicates during run time and do not calculate or validate the types of expressions at compile time.  Statically-typed languages---languages that use static type systems---that use values from dynamically-typed languages must verify that the values match their expected types.  Languages are assumed to exchange a common set of values that can be checked straightforwardly without coercion.  Mismatched values and expected types could cause type errors during run time and violate type soundness.  Ad-hoc polymorphism in dynamically-typed languages enables argument types to determine polymorphic function behavior.  Since determining function behavior is undecidable \cite{blume04}, actual types for these functions cannot be reliably calculated at language boundaries and compared to expected types.  Instead, they are wrapped in contracts \cite{findler02} that defer the checking of their parameter and result types until they are used during run time.  If they are never used, their types cannot be checked, but neither can they cause type errors.

The second incompatibility is parametricity.  Parametric polymorphism in statically-typed languages enables function types to be abstracted with type variables and then instantiated into concrete types.  Parametricity constrains the behavior of parametric polymorphic functions by ensuring that they behave the same regardless of the types and values of their arguments, and that functions with instantiated result types produce as their results the arguments associated with the same instantiated types.  Functions from dynamically-typed languages that use value predicates or conditions on arguments and are used as parametric polymorphic functions by languages that have parametricity can violate their parametricity.  Arguments for these functions must be obscured such that value predicates and conditions cannot examine them and annotated to ensure the correct ones are produced as results.

The third incompatibility is evaluation strategies.  Evaluation strategies determine the order in which languages evaluate expressions.  Eager evaluation evaluates expressions regardless of necessity, and lazy evaluation evaluates expressions only where necessary.  Lazy languages---languages that use lazy evaluation---can construct infinite streams as lists because they do not evaluate list elements when lists are constructed, but eager languages cannot because they do.  Since there exist lazy lists---lists in lazy languages---for which no naturally equivalent eager lists exist, lazy lists crossing to eager languages are not converted to eager lists.  Instead, elements of lazy lists are converted when accessed by eager languages if they are not lazy lists too.

The languages in the model must be able to express programs in which the aforementioned three incompatibilities arise.  Haskell, ML, and Scheme each possess a unique combination of properties that together are sufficient for this purpose: Haskell and ML use static type systems and have parametricity, Scheme uses a dynamic type system, ML and Scheme use eager evaluation, and Haskell uses lazy evaluation.

The rest of the paper is organized as follows: Chapter 2 defines the model of computation, Chapter 3 proves the type soundness of the model, Chapter 4 describes an implementation of the model, Chapter 5 discusses related work, Chapter 6 discusses future work, and Chapter 7 discusses the conclusions.
