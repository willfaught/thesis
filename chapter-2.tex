\chapter{Model of Computation}

The model of computation represents Haskell, ML, and Scheme with lambda calculus extended in various ways.  Expressions represent software components, and nesting component expressions expresses interoperation between them, where the inner component expression evaluates to the value given to the outer component expression.  Boundary expressions separate interoperating component expressions of different languages, indicate inner and outer languages, and declare the expected and actual types of the given values.  The reduction of boundary expressions converts values between languages.  The model extends the model of Kinghorn \cite{kinghorn07}, which extended the model of Matthews and Findler \cite{matthews07}.  The model comprises smaller models to ease comprehension and simplify organization.

\section{Core Models}

The core models are the subset of the model that define the languages, but do not make provisions for interoperation.

\subsection{Haskell Model}

The core Haskell model comprises the variables, functions, and function applications of lambda calculus; the type variables, type abstractions, and type applications of System F \cite{pierce02}; natural numbers and arithmetic operations; lists and list operations; conditions that use the natural number zero as true all other natural numbers as false; fixed-point operations; error reports; and types for type abstractions and all values.  Empty lists, functions, and error reports have type annotations to enable the calculation of their types.  Haskell values and evaluation contexts conform to an extended call-by-name (lazy) evaluation strategy.  Letter subscripts of grammar non-terminals denote the language to which they belong, and numbered superscripts denote individual instances of them.  Variable and type variable names are assumed to be unique across all languages.

$\Gamma\vdash_{H}e_{H}:T$ denotes the Haskell typing relation.  An expression $e_{H}$ is well-typed within the context $\Gamma$ if there is some type $T$ such that $\Gamma\vdash_{H}e_{H}:T$ is derivable.  $\Gamma\vdash_{H}T$ asserts the type $T$ is well-formed within the context $\Gamma$.  Where the context is empty, it is omitted from typing judgments.  Programs that contain free variables or free type variables are ill-typed.  Type equivalence is computed up to alpha-equivalence on bound type variables.  Letter subscripts of type relations denote the language to which they belong.  $T_{1}[T_{2}/X]$ denotes the substitution of type $T_{2}$ for free occurrences of type variable $X$ within type $T_{1}$.  Number subscripts and superscripts of grammar non-terminals in typing rules denote individual instances of them, but are absent where instances are unambigious.

$e_{H}^{1}[e_{H}^{2}/x]$ denotes the substitution of expression $e_{H}^{2}$ for free occurrences of variable $x$ within expression $e_{H}^{1}$.  Variable instances that occur on the right side of a reduction rule, but not its left, are new and unique.  Error reports reduce to errors and terminate the computation.  All reduction rules are defined with an unspecified evaluation context $\mathscr{E}$.  The evaluation of a single language instantiates $\mathscr{E}$ to $E_{H}$ for Haskell, to $E_{M}$ for ML, and to $E_{S}$ for Scheme.  Language interoperation instantiates $\mathscr{E}$ according to the language in which programs begin and end.  $\mathscr{E}$ is implicitly instantiated correctly in later examples.

\subsection{ML Model}

ML is identical to Haskell except that it uses an extended call-by-value (eager) evaluation strategy.  This difference affects list constructions and evaluation contexts.  Since Haskell reduces expressions only where necessary, and ML reduces expressions regardless of necessity, their definitions of values are different.  Haskell list constructions are values regardless of whether their heads and tails are values, but ML list constructions are values only where their heads and tails are values.  To reflect these differences, ML adds a list construction expression where the head and tail are expressions, denoted $\mathtt{cons}$ $e_{M}$ $e_{M}$, and changes the head and tail of its list construction value to values, denoted $\mathtt{cons}$ $v_{M}$ $v_{M}$.

ML evaluation contexts extend Haskell evaluation contexts such that all expressions are reduced and the order of evaluation is deterministic.  In addition to the Haskell definition, ML evaluation contexts are right subexpressions of function applications where left subexpressions are values, heads of list constructions, and tails of list construction where heads are values.

\subsection{Scheme Model}

Scheme is identical to ML except that it removes the static type system and adds a dynamic type system.  It removes all the types and type annotations for functions, empty lists, and error reports.  It removes type abstractions and type applications and the evaluation contexts, typing rules, and rewrite rules that contain them.

The dynamic type system adds value predicate expressions that determine the kinds of values.  $\mathtt{num?}$ $e_{S}$ determines whether $e_{S}$ is a natural number.  $\mathtt{list?}$ $e_{S}$ determines whether $e_{S}$ is a list.  $\mathtt{fun?}$ $e_{S}$ determines whether $e_{S}$ is a function.

In addition to ML evaluation contexts, Scheme evaluation contexts are the expression of value predicates, denoted $p$ $E_{S}$.

It adds a single type called The Scheme Type, $TST$.  Well-typed expressions have type $TST$, and well-typed programs are closed.

It changes the natural number condition to reduce to one if the guard is not zero, and possibly not a natural number.  It changes the list condition to reduce to one if the guard is not an empty list, and possibly not a list.  The value predicates reduce to $\overline{0}$ if true and $\overline{1}$ if false.

\input{model/core/haskell/grammar.tex}

\input{model/core/ml/grammar.tex}

\input{model/core/scheme/grammar.tex}

\input{model/core/haskell/typing-rules.tex}

\input{model/core/ml/typing-rules.tex}

\input{model/core/scheme/typing-rules.tex}

\input{model/core/haskell/operational-semantics.tex}

\input{model/core/ml/operational-semantics.tex}

\input{model/core/scheme/operational-semantics.tex}

\clearpage

\section{Interoperation Models}

The interoperation calculi extend the core calculi with new expressions, evaluation contexts, typing rules, and rewrite rules to enable interoperation.  They add boundary expressions, which represent values with actual and expected types crossing between languages.  Boundaries are denoted by two-letter acronyms, where the first letter names clients and the second letter names servers.  Expected types are superscripts to the left of the first letters, and actual types are superscripts to the right of the second letters.  Expressions to be reduced to values and cross languages are to the right of the letters and types, separated by a space.  For example, the expression $^{T_{1}}HM^{T_{2}}$ $e_{M}$ denotes $e_{M}$ with expected (Haskell) type $T_{1}$ and actual (ML) type $T_{2}$ crossing from ML to Haskell.  Boundaries can be nested within each other to express interoperation between more than two languages.  Since a set of $n$ interoperable languages requires $n\times(n-1)$ boundaries, this model requires six boundaries.

They add evaluation contexts for the subexpressions of boundaries ($^{T}HM^{T}$ $E_{M}$ for example).

They add typing rules for boundaries.  Boundaries are well-typed if their expected and actual types are well-formed and equivalent and the types of their subexpressions equal their actual types.  The types of boundaries are their expected types.  $TST$ is omitted from boundary notation because all well-typed Scheme expressions have type $TST$.

They add rewrite rules for every combination of boundary, expected and actual types, and syntactic forms of values.  Rewrite rules for boundaries that contain Scheme values that do not match their expected types reduce to type error reports.

The expected and actual types of boundaries determine their reduction.

\subsection{Natural Number Types}

Natural numbers do not change when they are converted because the languages share the same number domain.  For example, $^{N}HM^{N}$ $\overline{n}$ reduces to $\overline{n}$.

\subsection{List Types}

If a boundary has expected and actual list types ($^{[T]}HM^{[T]}$ $v_{M}$ for example), the value is either an empty list ($\mathtt{nil}^{T}$ for example), a list construction ($\mathtt{cons}$ $v_{M}^{1}$ $v_{M}^{2}$ for example), or a Haskell list construction embedded in ML ($^{[T]}MH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2})$ for example).  If it is an empty list, the boundary reduces to the empty list.  For example, $^{[T]}HM^{[T]}$ $\mathtt{nil}^{T}$ reduces to $\mathtt{nil}^{T}$.  If it is a list construction crossing from ML to Haskell, the boundary reduces to a list construction of the old head and tail wrapped in boundaries.  For example, $^{[T]}HM^{[T]}$ $(\mathtt{cons}$ $v_{M}^{1}$ $v_{M}^{2})$ reduces to $\mathtt{cons}$ $(^{T}HM^{T}$ $v_{M}^{1})$ $(^{[T]}HM^{[T]}$ $v_{M}^{2})$.  If it is a list construction crossing from Haskell to ML, the boundary is irreducible.  Since Haskell list constructions can be infinite, they cannot be mechanically converted to equivalent ML list constructions.  Therefore $^{[T]}MH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2})$ is a value.  Instead, ML head and tail operations on embedded Haskell list constructions reduce to embedded heads and tails.  For example, $\mathtt{hd}$ $(^{[T]}MH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2}))$ reduces to $^{T}MH^{T}$ $e_{H}^{1}$.  If it is a Haskell list construction embedded in ML, the boundary reduces to the list construction.  For example, $^{[T]}HM^{[T]}$ $(^{[T]}MH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2}))$ reduces to $\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2}$.

If a boundary has an expected Scheme type and an actual list type ($SH^{[T]}$ $v_{H}$ for example), the value is either an empty list, a list construction, or a Haskell list construction embedded in ML ($^{[T]}MH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2})$ for example).  If it is an empty list, the boundary reduces to an empty list.  For example, $SH^{[T]}$ $\mathtt{nil}^{T}$ reduces to $\mathtt{nil}$.  If it is an ML list construction, the boundary reduces to a list construction of the old head and tail wrapped in boundaries.  For example, $SM^{[T]}$ $(\mathtt{cons}$ $v_{M}^{1}$ $v_{M}^{2})$ reduces to $\mathtt{cons}$ $(SM^{T}$ $v_{M}^{1})$ $(SM^{[T]}$ $v_{M}^{2})$.  If it is a Haskell list construction, it is irreducible for the same reason that $^{[T]}MH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2})$ is irreducible, as discussed above.  Therefore $SH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2})$ is a value.  Instead, Scheme head and tail operations on embedded Haskell list constructions reduce to embedded heads and tails.  For example, $\mathtt{hd}$ $(SH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2}))$ reduces to $SH^{T}$ $e_{H}^{1}$.  If it is a Haskell list construction embedded in ML, the boundary reduces to the list construction embedded in Scheme.  For example, $SM^{[T]}$ $(^{[T]}MH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2}))$ reduces to $SH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2})$.

If a boundary has an expected list type and an actual Scheme type ($^{[T]}HS$ $v_{S}$ for example), the value is either an empty list, a list construction, or a Haskell list construction embedded in Scheme ($SH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2})$ for example).  If it is an empty list, the boundary reduces to an empty list of the corresponding type.  For example, $^{[T]}HS$ $\mathtt{nil}$ reduces to $\mathtt{nil}^{T}$.  If it is a list construction, the boundary reduces to a list construction of the old head and tail wrapped in boundaries.  For example, $^{[T]}HS$ $(\mathtt{cons}$ $v_{S}^{1}$ $v_{S}^{2})$ reduces to $\mathtt{cons}$ $(^{T}HS$ $v_{S}^{1})$ $(^{[T]}HS$ $v_{S}^{2})$.  If it is a Haskell list construction embedded in Scheme crossing to Haskell, the boundary reduces to the list construction.  For example, $^{[T]}HS$ $(SH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2}))$ reduces to $\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2}$.  If it is a Haskell list construction embedded in Scheme crossing to ML, the boundary reduces to the list construction embedded in ML.  For example, $^{[T]}MS$ $(SH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2}))$ reduces to $^{[T]}MH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2})$.

\subsection{Function Types}

Functions cannot be mechanically converted as they cross languages because the language grammars are different, Haskell and ML do not have a reasonable equivalent for every Scheme function, and functions may behave differently with different evaluation strategies.  Instead, server functions are wrapped in client functions.  The client functions apply the server function to their arguments and produce the results as their own.  This is made possible by languages performing substitution within themselves across boundaries.

In Figure \ref{function-1}, a single boundary with an expected function type is split into two boundaries that convert the Haskell argument to an equivalent Scheme argument and the Scheme result to an equivalent Haskell result.  Every boundary with a function type is split into two boundaries in this fashion.  The Scheme-to-Haskell boundary verifies the syntactic form of its value matches its expected type.  If its value is not some list of natural numbers, it reports a type error.  If the body of the Scheme function had been $\overline{0}$ instead of $\mathtt{nil}$, the computation would have reduced to $^{[N]}HS$ $\overline{0}$ instead of $^{[N]}HS$ $\mathtt{nil}$.  Since $\overline{0}$ is not a list, $^{[N]}HS$ $\overline{0}$ reduces to $\mathtt{wrong}$ ``Not a list" to report the type error.

\input{figures/function-1.tex}

The case for higher-order functions is more complex, but straightforward.  See Figure \ref{function-2} for an example.

\input{figures/function-2.tex}

\subsection{Forall Types}

If a boundary has expected and actual forall types ($^{\forall X.T}HM^{\forall X.T}$ $v_{M}$ for example), the value is either a type abstraction ($\Lambda X.e_{M}$ for example) or a Scheme value wrapped in an inner boundary ($^{\forall X.T}MS$ $v_{S}$ for example).  If it is a type abstraction, the boundary moves inside the type abstraction and wraps the expression.  For example, $^{\forall X.T}HM^{\forall X.T}$ $\Lambda X.e_{M}$ reduces to $\Lambda X.(^{T}HM^{T}$ $e_{M})$.  If it is a Scheme value wrapped in an inner boundary, the outer boundary reduces to a new boundary bridging the outer language and Scheme that contains the Scheme value.  For example, $^{\forall X.T}HM^{\forall X.T}$ $(^{\forall X.T}MS$ $v_{S})$ reduces to $^{\forall X.T}HS$ $v_{S}$.

If a boundary has an expected forall type and an actual Scheme type ($^{\forall X.T}HS$ $v_{S}$ for example), the value is a Scheme value.  Such a boundary is irreducible because Scheme does not have type abstractions.  Therefore $^{\forall X.T}HS$ $v_{S}$ and $^{\forall X.T}MS$ $v_{S}$ are values.  Nevertheless, there are useful Scheme values that correspond to forall types, and they ought to be convertible.  If the expected forall type is instantiated and the result is not a forall type, the boundary is reducible and the Scheme value is convertible.  However, Haskell and ML preserve parametricity, and instantiating the expected forall type does nothing to prevent the Scheme value, if it is a function, from breaking parametricity once converted.

Scheme functions with expected forall types can break parametricity by using value predicates and conditions to determine their behavior by the types and values of their arguments.  Haskell and ML must wrap their arguments for these functions such that Scheme value predicates and conditions cannot examine them.  Expected forall types of boundaries can be instantiated by applying those boundaries to types.  These type applications label their type arguments with unique labels, denoted $T^{a}$, before instantiating the expected forall types with them.  Boundaries with actual label types ($SH^{T^{a}}$ $e_{H}$ for example) are irreducible; Scheme value predicates and conditions cannot examine them.  Therefore $SH^{T^{a}}$ $e_{H}$ and $SM^{T^{a}}$ $v_{M}$ are values.  Scheme can return these wrapped arguments to Haskell and ML if the expected and actual types match.  For example, $^{T^{a}}HS$ $(SH^{T^{a}}$ $e_{H})$ reduces to $e_{H}$.  If they do not match, the outer boundary reduces to a parametricity error report.  See Figure \ref{forall-1} for an example.

\input{figures/forall-1.tex}

Since the Haskell and ML typing relations expect type applications to substitute types unchanged, they expect $\forall X.(X\rightarrow X)$, instantiated with $N$, to be $N\rightarrow N$.  Observe that the application of $^{\forall X.(X\rightarrow X)}HS$ $\lambda x_{1}.(\mathtt{if0}$ $x_{1}$ $\overline{1}$ $x_{1})$, which has type $\forall X.(X\rightarrow X)$, to $N$ reduces to $^{N^{a}\rightarrow N^{a}}HS$ $\lambda x_{1}.(\mathtt{if0}$ $x_{1}$ $\overline{1}$ $x_{1})$, which appears to have type $N^{a}\rightarrow N^{a}$.  The Haskell and ML typing relations resolve this conflict by removing all labels from expected and actual types before making typing judgements.  Therefore $^{N^{a}\rightarrow N^{a}}HS$ $\lambda x_{1}.(\mathtt{if0}$ $x_{1}$ $\overline{1}$ $x_{1})$ has type $N\rightarrow N$, as expected.  Rewrite rules remove labels where required to resolve type conflicts.  $T[T_{i}/T_{i}^{a}]$ denotes the replacement of every label type $T_{i}^{a}$ with its underlying type $T_{i}$ within $T$.

Scheme functions with expected forall types can also break parametricity by producing the wrong argument as their results.  Haskell and ML assume type variables for result types are instantiated along with one or more type variables for argument types.  For example, Haskell and ML assume a function with type $\forall X_{1}.(\forall X_{2}.(X_{1}\rightarrow(X_{2}\rightarrow X_{2}))$ reduces to its second argument because the second argument and the result share the same type variable.  Labels enable Haskell and ML to detect and report violations of these assumptions during run time.  Since unique labels are used for each application of a boundary to a type, they group argument and result types together.  Mismatched labels for expected and actual types of boundaries indicates that Scheme broke parametricity.  See Figure \ref{forall-2} for an example.

\input{figures/forall-2.tex}

If a boundary has an expected Scheme type and an actual forall type ($SH^{\forall X.T}$ $e_{H}$ for example), the value is either a type abstraction ($\Lambda X.e_{H}$ for example) or a Scheme value wrapped in an inner boundary ($^{\forall X.T}HS$ $v_{S}$ for example).  If the value is a type abstraction, the boundary is irreducible because Scheme does not have type abstractions.  Instead, the actual type is insantiated with, and the type abstraction is applied to, the lump type, denoted $L$.  If the result is not another type abstraction, the boundary is reducible.  Boundaries with expected lump types are irreducible; $^{L}HS$ $v_{S}$ and $^{L}MS$ $v_{S}$ are values.  Empty lists instantiated with the lump type convert as with other types because their conversions discard their type annotations.  Likewise, error reports instantiated with the lump type terminate the computation as with other types.  Polymorphic functions instantiated with the lump type satisfy the expectations of all languages because they convert to Scheme functions that can be applied to arguments of various types, but do not break parametricity.  These polymorphic functions can return their arguments to Scheme if the expected and actual types are lump types.  For example, $SH^{L}$ $(^{L}HS$ $v_{S})$ reduces to $v_{S}$.  See Figure \ref{forall-3} for an example.

\input{figures/forall-3.tex}

If it is a Scheme value wrapped in an inner boundary, the outer boundary reduces to the Scheme value.  For example, $SH^{\forall X.T}$ $(^{\forall X.T}HS$ $v_{S})$ reduces to $v_{S}$.

\clearpage

\input{model/interoperation/haskell/grammar.tex}

\input{model/interoperation/ml/grammar.tex}

\input{model/interoperation/scheme/grammar.tex}

\clearpage

\input{model/interoperation/haskell/typing-rules.tex}

\input{model/interoperation/ml/typing-rules.tex}

\input{model/interoperation/scheme/typing-rules.tex}

\clearpage

\input{model/interoperation/haskell/operational-semantics.tex}

\input{model/interoperation/ml/operational-semantics.tex}

\input{model/interoperation/scheme/operational-semantics.tex}

\clearpage