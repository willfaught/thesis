\chapter{Model of Computation}

Following Matthews and Findler \ref{matthews07}, the model of computation is based on System F.  It extends the simply-typed lambda calculus to facilitate the reuse of typed expressions by parameterizing them with type variables and providing a mechanism for substituting new types for where the types of subexpressions are variable



type variables, type abstractions, and type applications.  The parameterization of the types of expressions and the substitution semantics of type applications to facilitate reuse of typed expressions where the types of subexpressions are variable.  

System F is extended with lists, a fixed-point operation that enables recursion

---

The model of computation represents Haskell, ML, and Scheme with lambda calculus extended in various ways.  Expressions represent software components, and nesting component expressions expresses interoperation between them, where the inner component expression evaluates to the value given to the outer component expression.  Boundary expressions separate interoperating component expressions of different languages, indicate inner and outer languages, and declare the expected and actual types of the given values.  The reduction of boundary expressions converts values between languages.  The model extends the model of Kinghorn \cite{kinghorn07}, which extended the model of Matthews and Findler \cite{matthews07}.

The Haskell and ML models extend System F, which extends lambda calculus with explicit types that simplify the type soundness proofs and parametric polymorphism that approximates the type systems of Haskell and ML.  The Scheme model extends lambda calculus with a simple type system to detect unbound variables.

Hereafter the names Haskell, ML, and Scheme refer to their corresponding models, unless otherwise stated.

\section{Syntax}

Haskell types $T$ comprise lumps $L$, natural numbers $N$, variables $X$, lists $[T]$, labels $T^{a}$, functions $T\rightarrow T$, and foralls $\forall X.T$.  Haskell values $v_{H}$ comprise functions $\lambda x:T.e_{H}$, type abstractions $\Lambda X.e_{H}$, natural numbers $\overline{n}$, empty lists $\mathtt{nil}^{T}$, list constructions $\mathtt{cons}$ $e_{H}$ $e_{H}$, Scheme boundaries with lump expected types $^{L}HS$ $v_{S}$, and Scheme boundaries with forall expected types $^{\forall X.T}HS$ $v_{S}$.  Haskell expressions $e_{H}$ comprise variables $x$, function applications $e_{H}$ $e_{H}$, type applications $e_{H}$ $\lbrace T\rbrace$, arithmetic operations $+$ $e_{H}$ $e_{H}$ and $-$ $e_{H}$ $e_{H}$, empty list predicates $\mathtt{null?}$ $e_{H}$, conditions $\mathtt{if0}$ $e_{H}$ $e_{H}$ $e_{H}$, list operations $\mathtt{hd}$ $e_{H}$ and $\mathtt{tl}$ $e_{H}$, fixed-point operations $\mathtt{fix}$ $e_{H}$, error reports $\mathtt{wrong}^{T}$ string, ML boundaries $^{T}HM^{T}$ $e_{M}$, and Scheme boundaries $^{T}HS$ $e_{S}$.  Haskell evaluation contexts $E_{H}$ conform to a call-by-name (lazy) evaluation strategy.  Haskell holes are denoted $[\,]_{H}$.  Figure \ref{hg} defines the Haskell grammar and evaluation contexts.

$\overline{n}$ syntactically represents the natural number $n$.  The first subexpression in list constructions is the head and the second is the tail.  Tails that are empty lists signify the ends of lists.  Empty list predicates determine whether lists are empty.  The first subexpression in conditions is the test, the second is the true alternative, and the third is the false alternative.  Empty list predicates and conditions use the natural number zero as true and all other natural numbers as false.  List operations produce the heads and tails of list constructions.  Fixed-point operations render functions recursive.  Error reports signal error conditions.  ML and Scheme boundaries embed expressions from those languages in Haskell.  Functions, empty lists, and error reports have type annotations that enable the calculation of their types.

ML and Scheme have unforced values, which are forced values and Haskell boundaries, and forced values, which are

ML unforced values $u_{M}$ comprise forced values $v_{M}$ and Haskell boundaries $^{T}MH^{T}$ $e_{H}$.  ML forced values comprise functions, type abstractions, natural numbers, empty lists, list constructions $\mathtt{cons}$ $v_{M}$ $v_{M}$, Scheme boundaries with lump expected types $^{L}MS$ $v_{S}$, Scheme boundaries with forall expected types $^{\forall X.T}MS$ $v_{S}$, and Haskell boundaries with list expected types $^{[T]}MH^{[T]}$ $(\mathtt{cons}$ $e_{H}$ $e_{H})$.  ML expressions comprise unforced values $u_{M}$, variables, function applications, type applications, arithmetic operations, empty list predicates, conditions, list constructions $\mathtt{cons}$ $e_{M}$ $e_{M}$, list operations, fixed-point operations, error reports, and ML boundaries $^{T}MS$ $e_{S}$.  ML unforced evaluation contexts $U_{M}$ do not force the reduction of Haskell boundaries and conform to an extended call-by-value (eager) evaluation strategy.  ML forced evaluation contexts $E_{M}$ force the reduction of Haskell boundaries.  ML holes are denoted $[\,]_{M}$.  Figure \ref{mg} defines the ML grammar and evaluation contexts.

Scheme unforced values comprise forced values and Haskell boundaries $SH^{T}$ $e_{H}$.  Scheme forced values comprise functions, natural numbers, empty lists, list constructions $\mathtt{cons}$ $v_{S}$ $v_{S}$, Haskell boundaries with list actual types $SH^{[T]}$ $(\mathtt{cons}$ $e_{H}$ $e_{H})$, Haskell boundaries with label actual types $SH^{T^{a}}$ $v_{H}$, and ML boundaries with label actual types $SM^{T^{a}}$ $v_{M}$.  First, it does not have type abstractions, type applications, and fixed-point operations and the evaluation contexts that contain them.  Second, it does not have types.  Third, it does not have type annotations for functions, empty lists, and error reports.  Fourth, it has three value predicate expressions that determine whether values are functions $\mathtt{fun?}$ $e_{S}$, lists $\mathtt{list?}$ $e_{S}$, and natural numbers $\mathtt{nat?}$ $e_{S}$.  Figure \ref{sg} defines the Scheme grammar and evaluation contexts.

Letter subscripts of grammar non-terminals denote the language to which they belong, and numbered superscripts denote individual instances of them.  Variable and type variable names must be unique across all languages.

\section{Typing Rules}

Sch doesn't have Sys F stuff and , typing rules, and reduction rules that contain them

set membership

$\Gamma\vdash_{H}e_{H}:T$ denotes the Haskell typing relation.  An expression $e_{H}$ is well-typed within the context $\Gamma$ if there is some type $T$ such that $\Gamma\vdash_{H}e_{H}:T$ is derivable.  $\Gamma\vdash_{H}T$ asserts the type $T$ is well-formed within the context $\Gamma$.  Where the context is empty, it is omitted from typing judgments.  Programs that contain free variables or free type variables are ill-typed.  Type equivalence is computed up to alpha-equivalence on bound type variables.  Letter subscripts of type relations denote the language to which they belong.  $T_{1}[T_{2}/X]$ denotes the substitution of type $T_{2}$ for free occurrences of type variable $X$ within type $T_{1}$.  Number subscripts and superscripts of grammar non-terminals in typing rules denote individual instances of them, but are absent where instances are unambigious.

It has a single type is The Scheme Type, $TST$.  

\section{Operational Semantics}

$e_{H}^{1}[e_{H}^{2}/x]$ denotes the substitution of expression $e_{H}^{2}$ for free occurrences of variable $x$ within expression $e_{H}^{1}$.  Variable instances that occur on the right side of a reduction rule, but not its left, are new and unique.  Error reports reduce to errors and terminate the computation.  All reduction rules are defined with an unspecified evaluation context $\mathscr{E}$.  The evaluation of a single language instantiates $\mathscr{E}$ to $E_{H}$ for Haskell, to $E_{M}$ for ML, and to $E_{S}$ for Scheme.  Language interoperation instantiates $\mathscr{E}$ according to the language in which programs begin and end.  $\mathscr{E}$ is implicitly instantiated correctly in later examples.

\section{Interoperation Models}

The interoperation calculi extend the core calculi with new expressions, evaluation contexts, typing rules, and reduction rules to enable interoperation.  They add boundary expressions, which represent values with actual and expected types crossing between languages.  Boundaries are denoted by two-letter acronyms, where the first letter names clients and the second letter names servers.  Expected types are superscripts to the left of the first letters, and actual types are superscripts to the right of the second letters.  Expressions to be reduced to values and cross languages are to the right of the letters and types, separated by a space.  For example, the expression $^{T_{1}}HM^{T_{2}}$ $e_{M}$ denotes $e_{M}$ with expected (Haskell) type $T_{1}$ and actual (ML) type $T_{2}$ crossing from ML to Haskell.  Boundaries can be nested within each other to express interoperation between more than two languages.  Since a set of $n$ interoperable languages requires $n\times(n-1)$ boundaries, this model requires six boundaries.

They add evaluation contexts for the subexpressions of boundaries ($^{T}HM^{T}$ $E_{M}$ for example).

They add typing rules for boundaries.  Boundaries are well-typed if their expected and actual types are well-formed and equivalent and the types of their subexpressions equal their actual types.  The types of boundaries are their expected types.  $TST$ is omitted from boundary notation because all well-typed Scheme expressions have type $TST$.

They add reduction rules for every combination of boundary, expected and actual types, and syntactic forms of values.  Rewrite rules for boundaries that contain Scheme values that do not match their expected types reduce to type error reports.

The expected and actual types of boundaries determine their reduction.

\subsection{Natural Number Types}

Natural numbers do not change when they are converted because the languages share the same number domain.  For example, $^{N}HM^{N}$ $\overline{n}$ reduces to $\overline{n}$.

\subsection{List Types}

If a boundary has expected and actual list types ($^{[T]}HM^{[T]}$ $v_{M}$ for example), the value is either an empty list ($\mathtt{nil}^{T}$ for example), a list construction ($\mathtt{cons}$ $v_{M}^{1}$ $v_{M}^{2}$ for example), or a Haskell list construction embedded in ML ($^{[T]}MH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2})$ for example).  If it is an empty list, the boundary reduces to the empty list.  For example, $^{[T]}HM^{[T]}$ $\mathtt{nil}^{T}$ reduces to $\mathtt{nil}^{T}$.  If it is a list construction crossing from ML to Haskell, the boundary reduces to a list construction of the old head and tail wrapped in boundaries.  For example, $^{[T]}HM^{[T]}$ $(\mathtt{cons}$ $v_{M}^{1}$ $v_{M}^{2})$ reduces to $\mathtt{cons}$ $(^{T}HM^{T}$ $v_{M}^{1})$ $(^{[T]}HM^{[T]}$ $v_{M}^{2})$.  If it is a list construction crossing from Haskell to ML, the boundary is irreducible.  Since Haskell list constructions can be infinite, they cannot be mechanically converted to equivalent ML list constructions.  Therefore $^{[T]}MH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2})$ is a value.  Instead, ML head and tail operations on embedded Haskell list constructions reduce to embedded heads and tails.  For example, $\mathtt{hd}$ $(^{[T]}MH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2}))$ reduces to $^{T}MH^{T}$ $e_{H}^{1}$.  If it is a Haskell list construction embedded in ML, the boundary reduces to the list construction.  For example, $^{[T]}HM^{[T]}$ $(^{[T]}MH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2}))$ reduces to $\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2}$.

If a boundary has an expected Scheme type and an actual list type ($SH^{[T]}$ $v_{H}$ for example), the value is either an empty list, a list construction, or a Haskell list construction embedded in ML ($^{[T]}MH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2})$ for example).  If it is an empty list, the boundary reduces to an empty list.  For example, $SH^{[T]}$ $\mathtt{nil}^{T}$ reduces to $\mathtt{nil}$.  If it is an ML list construction, the boundary reduces to a list construction of the old head and tail wrapped in boundaries.  For example, $SM^{[T]}$ $(\mathtt{cons}$ $v_{M}^{1}$ $v_{M}^{2})$ reduces to $\mathtt{cons}$ $(SM^{T}$ $v_{M}^{1})$ $(SM^{[T]}$ $v_{M}^{2})$.  If it is a Haskell list construction, it is irreducible for the same reason that $^{[T]}MH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2})$ is irreducible, as discussed above.  Therefore $SH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2})$ is a value.  Instead, Scheme head and tail operations on embedded Haskell list constructions reduce to embedded heads and tails.  For example, $\mathtt{hd}$ $(SH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2}))$ reduces to $SH^{T}$ $e_{H}^{1}$.  If it is a Haskell list construction embedded in ML, the boundary reduces to the list construction embedded in Scheme.  For example, $SM^{[T]}$ $(^{[T]}MH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2}))$ reduces to $SH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2})$.

If a boundary has an expected list type and an actual Scheme type ($^{[T]}HS$ $v_{S}$ for example), the value is either an empty list, a list construction, or a Haskell list construction embedded in Scheme ($SH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2})$ for example).  If it is an empty list, the boundary reduces to an empty list of the corresponding type.  For example, $^{[T]}HS$ $\mathtt{nil}$ reduces to $\mathtt{nil}^{T}$.  If it is a list construction, the boundary reduces to a list construction of the old head and tail wrapped in boundaries.  For example, $^{[T]}HS$ $(\mathtt{cons}$ $v_{S}^{1}$ $v_{S}^{2})$ reduces to $\mathtt{cons}$ $(^{T}HS$ $v_{S}^{1})$ $(^{[T]}HS$ $v_{S}^{2})$.  If it is a Haskell list construction embedded in Scheme crossing to Haskell, the boundary reduces to the list construction.  For example, $^{[T]}HS$ $(SH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2}))$ reduces to $\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2}$.  If it is a Haskell list construction embedded in Scheme crossing to ML, the boundary reduces to the list construction embedded in ML.  For example, $^{[T]}MS$ $(SH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2}))$ reduces to $^{[T]}MH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2})$.

\subsection{Function Types}

Functions cannot be mechanically converted as they cross languages because the language grammars are different, Haskell and ML do not have a reasonable equivalent for every Scheme function, and functions may behave differently with different evaluation strategies.  Instead, server functions are wrapped in client functions.  The client functions apply the server function to their arguments and produce the results as their own.  This is made possible by languages performing substitution within themselves across boundaries.

In Figure \ref{function-1}, a single boundary with an expected function type is split into two boundaries that convert the Haskell argument to an equivalent Scheme argument and the Scheme result to an equivalent Haskell result.  Every boundary with a function type is split into two boundaries in this fashion.  The Scheme-to-Haskell boundary verifies the syntactic form of its value matches its expected type.  If its value is not some list of natural numbers, it reports a type error.  If the body of the Scheme function had been $\overline{0}$ instead of $\mathtt{nil}$, the computation would have reduced to $^{[N]}HS$ $\overline{0}$ instead of $^{[N]}HS$ $\mathtt{nil}$.  Since $\overline{0}$ is not a list, $^{[N]}HS$ $\overline{0}$ reduces to $\mathtt{wrong}$ ``Not a list" to report the type error.

\input{figures/function-1.tex}

The case for higher-order functions is more complex, but straightforward.  See Figure \ref{function-2} for an example.

\input{figures/function-2.tex}

\subsection{Forall Types}

If a boundary has expected and actual forall types ($^{\forall X.T}HM^{\forall X.T}$ $v_{M}$ for example), the value is either a type abstraction ($\Lambda X.e_{M}$ for example) or a Scheme value wrapped in an inner boundary ($^{\forall X.T}MS$ $v_{S}$ for example).  If it is a type abstraction, the boundary moves inside the type abstraction and wraps the expression.  For example, $^{\forall X.T}HM^{\forall X.T}$ $\Lambda X.e_{M}$ reduces to $\Lambda X.(^{T}HM^{T}$ $e_{M})$.  If it is a Scheme value wrapped in an inner boundary, the outer boundary reduces to a new boundary bridging the outer language and Scheme that contains the Scheme value.  For example, $^{\forall X.T}HM^{\forall X.T}$ $(^{\forall X.T}MS$ $v_{S})$ reduces to $^{\forall X.T}HS$ $v_{S}$.

If a boundary has an expected forall type and an actual Scheme type ($^{\forall X.T}HS$ $v_{S}$ for example), the value is a Scheme value.  Such a boundary is irreducible because Scheme does not have type abstractions.  Therefore $^{\forall X.T}HS$ $v_{S}$ and $^{\forall X.T}MS$ $v_{S}$ are values.  Nevertheless, there are useful Scheme values that correspond to forall types, and they ought to be convertible.  If the expected forall type is instantiated and the result is not a forall type, the boundary is reducible and the Scheme value is convertible.  However, Haskell and ML preserve parametricity, and instantiating the expected forall type does nothing to prevent the Scheme value, if it is a function, from breaking parametricity once converted.

Scheme functions with expected forall types can break parametricity by using value predicates and conditions to determine their behavior by the types and values of their arguments.  Haskell and ML must wrap their arguments for these functions such that Scheme value predicates and conditions cannot examine them.  Expected forall types of boundaries can be instantiated by applying those boundaries to types.  These type applications label their type arguments with unique labels, denoted $T^{a}$, before instantiating the expected forall types with them.  Boundaries with actual label types ($SH^{T^{a}}$ $e_{H}$ for example) are irreducible; Scheme value predicates and conditions cannot examine them.  Therefore $SH^{T^{a}}$ $e_{H}$ and $SM^{T^{a}}$ $v_{M}$ are values.  Scheme can return these wrapped arguments to Haskell and ML if the expected and actual types match.  For example, $^{T^{a}}HS$ $(SH^{T^{a}}$ $e_{H})$ reduces to $e_{H}$.  If they do not match, the outer boundary reduces to a parametricity error report.  See Figure \ref{forall-1} for an example.

\input{figures/forall-1.tex}

Since the Haskell and ML typing relations expect type applications to substitute types unchanged, they expect $\forall X.(X\rightarrow X)$, instantiated with $N$, to be $N\rightarrow N$.  Observe that the application of $^{\forall X.(X\rightarrow X)}HS$ $\lambda x_{1}.(\mathtt{if0}$ $x_{1}$ $\overline{1}$ $x_{1})$, which has type $\forall X.(X\rightarrow X)$, to $N$ reduces to $^{N^{a}\rightarrow N^{a}}HS$ $\lambda x_{1}.(\mathtt{if0}$ $x_{1}$ $\overline{1}$ $x_{1})$, which appears to have type $N^{a}\rightarrow N^{a}$.  The Haskell and ML typing relations resolve this conflict by removing all labels from expected and actual types before making typing judgements.  Therefore $^{N^{a}\rightarrow N^{a}}HS$ $\lambda x_{1}.(\mathtt{if0}$ $x_{1}$ $\overline{1}$ $x_{1})$ has type $N\rightarrow N$, as expected.  Rewrite rules remove labels where required to resolve type conflicts.  $T[T_{i}/T_{i}^{a}]$ denotes the replacement of every label type $T_{i}^{a}$ with its underlying type $T_{i}$ within $T$.

Scheme functions with expected forall types can also break parametricity by producing the wrong argument as their results.  Haskell and ML assume type variables for result types are instantiated along with one or more type variables for argument types.  For example, Haskell and ML assume a function with type $\forall X_{1}.(\forall X_{2}.(X_{1}\rightarrow(X_{2}\rightarrow X_{2}))$ reduces to its second argument because the second argument and the result share the same type variable.  Labels enable Haskell and ML to detect and report violations of these assumptions during run time.  Since unique labels are used for each application of a boundary to a type, they group argument and result types together.  Mismatched labels for expected and actual types of boundaries indicates that Scheme broke parametricity.  See Figure \ref{forall-2} for an example.

\input{figures/forall-2.tex}

If a boundary has an expected Scheme type and an actual forall type ($SH^{\forall X.T}$ $e_{H}$ for example), the value is either a type abstraction ($\Lambda X.e_{H}$ for example) or a Scheme value wrapped in an inner boundary ($^{\forall X.T}HS$ $v_{S}$ for example).  If the value is a type abstraction, the boundary is irreducible because Scheme does not have type abstractions.  Instead, the actual type is insantiated with, and the type abstraction is applied to, the lump type, denoted $L$.  If the result is not another type abstraction, the boundary is reducible.  Boundaries with expected lump types are irreducible; $^{L}HS$ $v_{S}$ and $^{L}MS$ $v_{S}$ are values.  Empty lists instantiated with the lump type convert as with other types because their conversions discard their type annotations.  Likewise, error reports instantiated with the lump type terminate the computation as with other types.  Polymorphic functions instantiated with the lump type satisfy the expectations of all languages because they convert to Scheme functions that can be applied to arguments of various types, but do not break parametricity.  These polymorphic functions can return their arguments to Scheme if the expected and actual types are lump types.  For example, $SH^{L}$ $(^{L}HS$ $v_{S})$ reduces to $v_{S}$.  See Figure \ref{forall-3} for an example.

\input{figures/forall-3.tex}

If it is a Scheme value wrapped in an inner boundary, the outer boundary reduces to the Scheme value.  For example, $SH^{\forall X.T}$ $(^{\forall X.T}HS$ $v_{S})$ reduces to $v_{S}$.

\clearpage

\input{model/haskell/grammar.tex}

\clearpage

\input{model/haskell/typing-rules.tex}

\clearpage

\input{model/haskell/operational-semantics/haskell.tex}

\clearpage

\input{model/haskell/operational-semantics/ml.tex}

\clearpage

\input{model/haskell/operational-semantics/scheme.tex}

\clearpage

\input{model/ml/grammar.tex}

\clearpage

\input{model/ml/typing-rules.tex}

\clearpage

\input{model/ml/operational-semantics/ml.tex}

\clearpage

\input{model/ml/operational-semantics/haskell.tex}

\clearpage

\input{model/ml/operational-semantics/scheme.tex}

\clearpage

\input{model/scheme/grammar.tex}

\clearpage

\input{model/scheme/typing-rules.tex}

\clearpage

\input{model/scheme/operational-semantics/scheme.tex}

\clearpage

\input{model/scheme/operational-semantics/haskell.tex}

\clearpage

\input{model/scheme/operational-semantics/ml.tex}

\clearpage

\input{model/unbrand.tex}

\input{model/equality.tex}