\chapter{Model of Computation}

Extended lambda calculi represent the languages.  The lambda calculus is a simple model of computation that embodies the notions of abstracting patterns into functions and applying function abstractions to concrete instances of patterns.  Computation is done by substituting function arguments for free occurrences of corresponding variables within function bodies.  Interoperation between calculi is represented by nesting one language within another as an expression embedded within special syntactic forms that indicate a change of language and expected types of expressions for either side of the boundary.

\section{Haskell}

The Haskell calculus extends the lambda calculus in several ways.  It adds a type system called System F, which provides parametric polymorphism whereby the types of terms can be parameterized and instantiated for specific types.  Types are defined explicitly by annotations for function parameters and for other terms, type abstractions for parameterizing the type of a term, and type applications for instantiating a type abstraction with a type.  The presence of explicit types enables the type of any term to be determined, which can be used to determine whether a type error would occur if the term were evaluated.  If no type errors would occur, the term is said to be well-typed; otherwise, it is said to be ill-typed or to have no type.

The addition of System F renders the calculus unequivalent to a Turing machine because recursive functions cannot have types.  To enable recursion and restore Turing equivalence, a fixed-point operator is added.  The fixed-point operator consumes a function that takes as its parameter its body and produces the body rendered recursive.

In addition, it adds natural numbers, addition and subtraction operations to combine natural numbers, and conditions to choose behavior according to natural numbers.  It adds lists, which are either a construction of head and tail expressions or empty and operations that access head and tail expressions.

Furthermore, it imposes a lazy evaluation strategy where function arguments are not evaluated before term substitution.

A term is any instance of any syntactic form.  A reduction or evaluation is a step of computation that applies a rewrite rule to a term.  A value is a term that is irreducible.  An expression is a value or a reducible term.  Letter subscripts of grammar non-terminals denote the language to which they belong.

Haskell values, denoted $v_{H}$, are comprised of natural numbers, denoted $\overline{n}$, which syntactically represents the natural number $n$; functions, denoted $\lambda x:T.e_{H}$; type abstractions, denoted $\Lambda X.e_{H}$; list constructions, denoted $\mathtt{cons}$ $e_{H}$ $e_{H}$; and empty lists, denoted $\mathtt{nil}^{T}$.  Haskell expressions, denoted $e_{H}$, are comprised of variables, denoted $x$; term applications, denoted $e_{H}$ $e_{H}$; type applications, denoted $e_{H}$ $\lbrace T\rbrace$; conditions, denoted $\mathtt{if0}$ $e_{H}$ $e_{H}$ $e_{H}$; arithmetic operations, denoted $+$ $e_{H}$ $e_{H}$ and $-$ $e_{H}$ $e_{H}$, list head and tail accessor operations, denoted $\mathtt{hd}$ $e_{H}$ and $\mathtt{tl}$ $e_{H}$; and fixed-point operations, denoted $\mathtt{fix}$ $e_{H}$.  Types, denoted $T$, are comprised of natural numbers, denoted $N$; type variables, denoted $X$; functions, denoted $T\rightarrow T$; universal types, denoted $\forall X.T$; and lists, denoted $[T]$.  Haskell evaluation contexts, denoted $E_{H}$, determine the evaluation strategy by constraining which term matches with the Haskell hole, denoted $[\,]_{H}$.  A Haskell evaluation context can be the Haskell hole, the left term of a term application, the left term of a type application, the guard of a condition, the left operand of an arithmetic operation, the right operand of an arithmetic operation if the left operand is a natural number, the operand of a head or tail access operation, or the operand of a fixed-point operation.  Haskell core terms are summarized in Figure \ref{hct}.

\input{model/hct.tex}

All variables and type variables in all languages must be unique.  Alpha conversion is implicitly used to resolve name conflicts.

Number superscripts of grammar non-terminals denote individual instances of them.

A Haskell type statement can assert a type $T$ is well-formed and contains zero or more free type variables that are in some context $\Gamma$, denoted $\Gamma\vdash_{H}T$.  If a type $T$ is well-formed but contains no free type variables, the context can be omitted, denoted $\vdash_{H}T$.  It can also assert the type $T$ of a term $e_{H}$, denoted $\Gamma\vdash_{H}e_{H}:T$.  A new context can be constructed from an old context $\Gamma$ by extending it with type variables and variable-type associations, denoted $\Gamma,X$ and $\Gamma,x:T$, respectively.  The letter subscript of the type judgment symbol $\vdash$ indicates the typing rules of which language to use.  Type substitution substitutes one type for a second type within a third type, denoted $T_{3}[T_{1}/T_{2}]$.  The Haskell core typing rules are in Figure \ref{hctr}.

\input{model/hctr.tex}

All rewrite rules are defined with an unspecified evaluation context $\mathscr{E}$.  The evaluation of a single language would instantiate $\mathscr{E}$ to $E_{H}$ for Haskell, to $E_{M}$ for ML, and to $E_{S}$ for Scheme.  The evaluation of multiple languages would instantiate $\mathscr{E}$ according to the language in which programs begin and end.  The Haskell core operational semantics are in Figure \ref{hcos}.

\input{model/hcos.tex}

