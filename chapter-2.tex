\chapter{Model of Computation}

Embedding server languages within client languages as expressions succinctly expresses the client-server interaction of interoperation.  Embedded server expressions evaluate to values and convert to equivalent client values.  Value conversion represents servers sending data and clients receiving them.  Since Haskell, ML, and Scheme are functional languages, extended lambda calculi can represent them.

Lambda calculus is a minimal model of computation that embodies the notions of abstracting patterns into functions and applying function abstractions to concrete instances of patterns.  Computation is done by substituting function arguments for free occurrences of corresponding variables within function bodies.  Interoperation between lambda calculi is represented by nesting languages within languages expressions embedded within special syntactic forms that indicate a change of language and expected and actual types of values for both sides of boundaries.  Evaluation contexts determine the evaluation strategy.

\section{Core Calculi}

\subsection{Haskell}

Lambda calculus is comprised of functions, variables, and function applications.  Haskell extends lambda calculus in several ways.  First, it adds natural numbers, addition and subtraction operations for natural numbers, and a condition that uses the natural number zero as true and all other natural numbers as false.

Second, it adds list constructions containing pairs of head and tail expressions, empty lists, operations to access head and tail expressions within list constructions, a condition that uses empty lists as true and list constructions as false, and error reports for head and tail operations that operate on empty lists.

Third, it adds a static type system called System F.  System F adds types for natural numbers, lists, and functions and the expressions that contain them.  If the type of an expression is valid, it is well-typed; otherwise, it is ill-typed.  Type errors cannot occur in well-typed expressions.  Haskell does not compute ill-typed expressions.  It adds type annotations to some expressions to enable the calculation and validation of expression types.  It adds parametric polymorphism whereby the types of expressions can be parameterized by type variables and type abstractions and then instantiated with type applications.  It adds types for type variables and type abstractions.

System F renders Haskell Turing-incomplete because Haskell cannot express recursive functions.  Haskell adds a fixed-point operator to restore Turing-completeness.  The operand of the fixed-point operator is a function of a recursive function over the body of the recursive function.

Fourth, the values and evaluation contexts of Haskell follow the spirit of lazy evaluation in that expressions are reduced only where necessary.

An expression is an instance of any syntactic form.  A reduction or evaluation is a step of computation that applies a rewrite rule of an operational semantics to an expression.  A value is an expression that is irreducible.  Letter subscripts of grammar non-terminals and relations denote the language to which they belong.

Types, denoted $T$, are comprised of natural numbers, denoted $N$; type variables, denoted $X$; functions, denoted $T\rightarrow T$; universally-quantified (forall) types, denoted $\forall X.T$; and lists, denoted $[T]$.

Haskell values, denoted $v_{H}$, are comprised of natural numbers, denoted $\overline{n}$, which syntactically represents the natural number $n$; list constructions, denoted $\mathtt{cons}$ $e_{H}$ $e_{H}$; empty lists, denoted $\mathtt{nil}^{T}$; functions, denoted $\lambda x:T.e_{H}$; and type abstractions, denoted $\Lambda X.e_{H}$.

Haskell expressions, denoted $e_{H}$, are comprised of variables, denoted $x$; function applications, denoted $e_{H}$ $e_{H}$; type applications, denoted $e_{H}$ $\lbrace T\rbrace$; addition and subtraction operations, denoted $+$ $e_{H}$ $e_{H}$ and $-$ $e_{H}$ $e_{H}$, respectively; natural number conditions, denoted $\mathtt{if0}$ $e_{H}$ $e_{H}$ $e_{H}$; head and tail operations, denoted $\mathtt{hd}$ $e_{H}$ and $\mathtt{tl}$ $e_{H}$, respectively; list conditions, denoted $\mathtt{ifnil}$ $e_{H}$ $e_{H}$ $e_{H}$; fixed-point operations, denoted $\mathtt{fix}$ $e_{H}$; and error reports, denoted $\mathtt{wrong}^{T}$ string.

Haskell evaluation contexts, denoted $E_{H}$, determine the Haskell evaluation strategy by constraining which expression matches the Haskell hole.  Haskell evaluation contexts are comprised of the Haskell hole, denoted $[\,]_{H}$; left expressions of function applications, denoted $E_{H}$ $e_{H}$; left expressions of type applications, denoted $E_{H}$ $\lbrace T\rbrace$; left operands of arithmetic operations, denoted $o$ $E_{H}$ $e_{H}$; right operands of arithmetic operations if left operands are values, denoted $o$ $v_{H}$ $E_{H}$; guards of natural number conditions, denoted $\mathtt{if0}$ $E_{H}$ $e_{H}$ $e_{H}$; operands of head and tail operations, denoted $f$ $E_{H}$; guards of list conditions, denoted $\mathtt{ifnil}$ $E_{H}$ $e_{H}$ $e_{H}$; and operands of fixed-point operations, denoted $\mathtt{fix}$ $E_{H}$.

Variables and type variables are unique across all languages.  Alpha conversion implicitly resolves name conflicts.

The Haskell typing relation, denoted $\Gamma\vdash_{H}e_{H}:T$, is defined by a set of typing rules that assign types to expressions \cite{pierce02}.  $\Gamma\vdash_{H}e_{H}:T$ is a typing statement that asserts the type of an expression and typing rules are implications between typing statements.  Where the type of an expression depends on the types of its subexpressions, its typing rule uses typing statements about those subexpressions as premises for its conclusion.  An expression $e_{H}$ is well-typed if there is some $T$ with the context $\Gamma$ such that $\Gamma\vdash_{H}e_{H}:T$.  A context is a set of assumptions about the types of variables and the abstraction of type variables.  Since all programs are assumed to be closed, programs containing free variables or free type variables are ill-typed.  Adding to the context $\Gamma$ assumptions about the type variable $X$ and the type $T$ of variable $x$ is denoted $\Gamma,X$ and $\Gamma,x:T$, respectively.  The typing statement $\Gamma\vdash_{H}T$ asserts the type $T$ is well-formed with the context $\Gamma$.  Where the context is empty, it is omitted from typing statements.

Natural numbers, addition and subtraction operations and their operands, and guards of natural number conditions have type $N$.  Functions, left expressions of function applications, and operands of fixed-point operations have type $T_{1}\rightarrow T_{2}$.  Type abstractions and expressions of type applications have type $\forall X.T$.  List constructions, tails of list constructions, empty lists, tail operations, operands of head and tail operations, and guards of list conditions have type $[T]$.

Variables have the types they are assumed to have by the context.  If the context does not assume the type of a variable, the variable occurs free and the expression is ill-typed.  If the context does not assume the abstraction of a type variable, the type variable occurs free and the expression is ill-typed.  Function values, empty lists, and error reports have type annotations because their types cannot be calculated otherwise.  Type substitution substitutes one type, $T_{1}$, for free occurrences of a type variable, $X$, within a second type, $T_{2}$, denoted $T_{2}[T_{1}/X]$.  Number subscripts and superscripts of grammar symbols in a typing rule denote distinct instances of them.  Numbers are absent where there is a single instance of a grammar symbol in a typing rule.

Haskell computations are defined by a set of rewrite rules called an operational semantics.  A rewrite rule rewrites a reducible expression in an evaluation context that matches its left side according to its right side.  Function applications substitute the argument for free occurrences of the function parameter within the function body.  Type applications substitute the argument for free occurrences of the type abstraction parameter within the type abstraction body.  Addition and subtraction operations reduce to the addition and subtraction of their operands, respectively.  Natural number conditions reduce to their true or false alternatives if their guards are zero or not zero, respectively.  Head and tail operations on list constructions reduce to the heads and tails of their operands, respectively.  Head and tail operations on empty lists reduce to error reports.  List conditions reduce to their true or false alternatives if their guards are empty lists or list constructions, respectively.  Fixed-point operations reduce to their operands substituted for the function parameters of their operands within the function bodies of their operands.  Error reports reduce to errors and terminate the computation.

Expression substitution substitutes one expression, $e_{H}^{1}$, for a variable, $x$, within a second expression, $e_{H}^{2}$, denoted $e_{H}^{2}[e_{H}^{1}/x]$.  Variable instances that occur only on the right side of a rewrite rule must be unique.  All rewrite rules are defined with an unspecified evaluation context $\mathscr{E}$.  The evaluation of a single language would instantiate $\mathscr{E}$ to $E_{H}$ for Haskell, to $E_{M}$ for ML, and to $E_{S}$ for Scheme.  The interoperation of languages would instantiate $\mathscr{E}$ according to the language in which programs begin and end.

\subsection{ML}

ML is identical to Haskell except that it uses strict evaluation instead of lazy evaluation.  This difference affects list constructions and evaluation contexts.  Haskell reduces expressions only where necessary and ML reduces expressions regardless of necessity, thus their definition of values are different.  Haskell list constructions are values regardless of whether their heads and tails are values, but ML list constructions are values where their heads and tails are values.  To reflect these differences, ML adds a list construction expression where the head and tail are expressions, denoted $\mathtt{cons}$ $e_{M}$ $e_{M}$, and changes the head and tail of the list construction value to values, denoted $\mathtt{cons}$ $v_{M}$ $v_{M}$.

ML evaluation contexts extend Haskell evaluation contexts such that all expressions are reduced and the order of evaluation is deterministic.  In addition to the Haskell definition, ML evaluation contexts are right expressions of function applications where left expression are values, heads of list constructions, and tails of list construction where heads are values.

\subsection{Scheme}

Scheme is identical to ML except that it removes the static type system and adds a dynamic type system.  It removes all the types and type annotations for functions, empty lists, and error reports.  It removes type abstractions and type applications and the evaluation contexts, typing rules, and rewrite rules that contain them.

The dynamic type system adds type predicate expressions that determine the types of values.  $\mathtt{num?}$ $e_{S}$ determines whether $e_{S}$ is a natural number.  $\mathtt{list?}$ $e_{S}$ determines whether $e_{S}$ is a list.  $\mathtt{fun?}$ $e_{S}$ determines whether $e_{S}$ is a function.

In addition to ML evaluation contexts, Scheme evaluation contexts are the expression of type predicates, denoted $p$ $E_{S}$.

It adds a single type called The Scheme Type, $TST$.  Well-typed expressions do not have free variables and have type $TST$.

It changes the natural number condition to reduce to one if the guard is not zero, and possibly not a natural number.  It changes the list condition to reduce to one if the guard is not an empty list, and possibly not a list.  The type predicates reduce to the natural number zero if true and the natural number one if false.

\input{model/hce.tex}
\input{model/mce.tex}
\input{model/sce.tex}
\input{model/hctr.tex}
\input{model/mctr.tex}
\input{model/sctr.tex}
\input{model/hcos.tex}
\input{model/mcos.tex}
\input{model/scos.tex}

\section{Interoperation Calculi}

The interoperation calculi extend the core calculi with new expressions, evaluation contexts, typing rules, and rewrite rules to express interoperation.  They add boundary expressions, which represent values with actual (server) and expected (client) types crossing from server languages to client languages.  Boundaries are denoted by two-letter acronyms, where the first letter names servers and the second letters names clients.  Expected types are superscripts to the left of first letters, and actual types are superscripts to the right of second letters.  Expressions to be reduced to values and cross between languages are to the right of the letters and types, separated by a space.  For example, the expression $^{T_{1}}HM^{T_{2}}$ $e_{M}$ denotes ML expression $e_{M}$ with expected type $T_{1}$ and actual type $T_{2}$ crossing from ML to Haskell.  Boundaries can be nested within each other to express interoperation between more than two languages.  Since a set of $n$ interoperable languages requires $n\times(n-1)$ boundary expressions, this model requires six boundaries.

They add evaluation contexts for the expressions of boundaries, $^{T}HM^{T}$ $E_{M}$ for example.

They add typing rules for boundaries.  For a boundary to be well-typed, its expected and actual types must be well-formed and equivalent and the type of its expression must equal the actual type of the boundary.  The types of boundaries are their expected types.  $TST$ is omitted from boundary notation because all well-typed Scheme expressions have type $TST$.

They add rewrite rules for every combination of boundary, expected and actual types, and syntactic forms of values.  Rewrite rules for boundaries containing Scheme values verify that their syntactic forms match their expected types and report type errors.  Rewrite rules for boundaries containing Haskell or ML values do not validate their types because the Haskell and ML type systems guarantee they are valid.

The expected and actual types of boundaries determine their reduction.

\subsection{Natural Number Types}

Natural numbers do not change when they cross languages because the languages have the same number domain.  For example, $^{N}HM^{N}$ $\overline{n}$ reduces to $\overline{n}$.  For $^{N}HS$ $v_{S}$ and $^{N}MS$ $v_{S}$, where $v_{S}$ is not a natural number, the boundaries reduce to type error reports.

\subsection{Function Types}

Functions cannot be directly converted when they cross languages because the language grammars are different, Haskell and ML do not have a reasonable equivalent for every Scheme function, and functions may behave differently with different evaluation strategies.  Instead, server functions are wrapped in client functions.  The client functions apply the server function to their arguments and produce the server function results as their own.  This is made possible by languages performing substitution within themselves across boundaries.  Observe the Scheme function $\lambda x_{1}.\mathtt{nil}$ cross to Haskell with expected type $N\rightarrow[N]$ and be applied to $\overline{0}$:

\input{figures/function-1.tex}

In the above example, a single boundary with a function type is split into two boundaries that convert the Haskell argument to an equivalent Scheme argument and the Scheme result to an equivalent Haskell result.  Every boundary with a function type is split into two boundaries in this fashion.  The Scheme-to-Haskell boundary verifies the syntactic form of its value matches its expected type.  If its value is not some list of natural numbers, it reports a type error.  If the body of the Scheme function had been $\overline{0}$ instead of $\mathtt{nil}$, the computation would reduce to $^{[N]}HS$ $\overline{0}$ instead of $^{[N]}HS$ $\mathtt{nil}$.  Since $\overline{0}$ does not have the equivalent type $[N]$, $^{[N]}HS$ $\overline{0}$ reduces to $\mathtt{wrong}$ ``Not a list" to report the type error.

The case for higher-order functions is more complex, but straightforward.  Observe the Scheme function $\lambda x_{1}.(x_{1}$ $\overline{0})$ cross to Haskell with expected type $(N\rightarrow N)\rightarrow N$ and be applied to $\lambda x_{2}:N.x_{2}$:

\input{figures/function-2.tex}

\subsection{Forall Types}

If the expected and actual types of a boundary are a forall type ($^{\forall X.T}HM^{\forall X.T}$ $v_{M}$ for example), the value is either a type abstraction ($\Lambda X.e_{M}$ for example) or a Scheme value wrapped in an inner boundary ($^{\forall X.T}MS$ $v_{S}$ for example).  If it is a type abstraction, the boundary moves inside the type abstraction and wraps the expression.  For example, $^{\forall X.T}HM^{\forall X.T}$ $\Lambda X.e_{M}$ reduces to $\Lambda X.(^{T}HM^{T}$ $e_{M})$.  If it is a Scheme value wrapped in an inner boundary, the outer boundary reduces to a new boundary bridging the outer language and Scheme that contains the Scheme value.  For example, $^{\forall X.T}HM^{\forall X.T}$ $(^{\forall X.T}MS$ $v_{S})$ reduces to $^{\forall X.T}HS$ $v_{S}$.

If the expected and actual types of a boundary are a forall type and the Scheme type, respectively, the value is a Scheme value.  Such a boundary is irreducible because Scheme does not have type abstractions.  Therefore $^{\forall X.T_{1}}HS$ $v_{S}$ and $^{\forall X.T_{1}}MS$ $v_{S}$ are values.  Nevertheless, there are useful Scheme values that correspond to forall types, and they ought to be convertable.  If the expected type of the boundary is instantiated and it is not a forall type, the boundary is reducible and the Scheme value can be converted.  However, Haskell and ML preserve parametricity, and instantiating the expected type of the boundary does nothing to prevent the Scheme value, if it is a function, from breaking parametricity once converted.

Scheme functions with expected forall types can break parametricity by using type predicates and conditions to determine their behavior by the types and values of their arguments.  Haskell and ML must wrap their arguments for these functions such that Scheme predicates and conditions cannot examine them.  This is done by labeling instantiations of expected forall types with unique labels, denoted $T^{a}$, and making boundaries with labeled actual types---$SH^{T^{a}}$ $e_{H}$ for example---irreducible; Scheme type predicates and conditions cannot examine them.  Therefore $SH^{T^{a}}$ $e_{H}$ and $SM^{T^{a}}$ $v_{M}$ are values.  Expected types of boundaries can be instantiated by applying those boundaries to types.  The reductions of these type applications label the type arguments before instantiating the expected types with them.  See Figure \ref{forall-1} for an example.

\input{figures/forall-1.tex}

Natural number conditions reduce to their true alternatives only if their guards are $\overline{0}$.  $\mathtt{if0}$ $(SH^{N^{a}}$ $\overline{0})$ $\overline{1}$ $(SH^{N^{a}}$ $\overline{0})$ reduces to $(SH^{N^{a}}$ $\overline{0})$ because the guard is $(SH^{N^{a}}$ $\overline{0})$, which is not equal to $\overline{0}$.  If Scheme functions with labeled expected types produce their arguments as their results, the arguments can cross back to Haskell and ML if the expected and actual types are equal.  Therefore $^{N^{a}}HS$ $(SH^{N^{a}}$ $\overline{0})$ reduces to $\overline{0}$.  If the expected type of the outer boundary and the actual type of the inner boundary are not equal, the outer boundary reduces to a parametricity error report.

Observe that $(^{\forall X.(X\rightarrow X)}HS$ $\lambda x_{1}.(\mathtt{if0}$ $x_{1}$ $\overline{1}$ $x_{1})$ $\lbrace N\rbrace)$, which has type $\forall X.(X\rightarrow X)$, reduces to $^{N^{a}\rightarrow N^{a}}HS$ $\lambda x_{1}.(\mathtt{if0}$ $x_{1}$ $\overline{1}$ $x_{1})$, which has type $N^{a}\rightarrow N^{a}$.  $N^{a}\rightarrow N^{a}$ conflicts with $N\rightarrow N$, the type expected by other Haskell expressions.  The Haskell and ML typing relations resolve this conflict by removing all labels from expected and actual types.  For example, $\Gamma\vdash_{H}{^{T}H}S$ $e_{S}:T[T_{i}/T^{a}_{i}]$, where $T[T_{i}/T_{i}^{a}]$ denotes the substitution of every labeled type $T_{i}^{a}$ for the underlying type $T_{i}$ within $T$.

Scheme functions with expected forall types can also break parametricity by producing the wrong argument as their results.  Haskell and ML assume type variables for result types are instantiated along with one or more type variables for argument types.  For example, Haskell and ML assume a function with type $\forall X_{1}.(\forall X_{2}.(X_{1}\rightarrow(X_{2}\rightarrow X_{2}))$ reduces to its second argument because the second argument and the result share the same type variable.  Labels enforce this assumption because unique labels are used for each application of a boundary to a type.  Unique labels group argument and result types together, and mismatched labels for expected and actual types of boundaries indicates that Scheme broke parametricity.  See Figure \ref{forall-2} for an example.

\input{figures/forall-2.tex}

If the expected and actual types of a boundary expression are the Scheme type and a universal type, respectively, the contained value is either a type abstraction or a Scheme value contained within another boundary expression.

If it is a type abstraction, $\Lambda X.e_{H}$ with type $\forall X.T$ for example, it may contain parametrically polymorphic functions of types containing $X$.  Since those functions are parametrically polymorphic, they cannot examine the types or values of their arguments.  Therefore Scheme arguments for these functions cannot cross the boundary to Haskell and ML.  In addition, the function types must be instantiated with a type that would enable them to accept any Scheme argument.  The lump type $L$ is added to be used in these situations.  $^{L}HS$ $v_{S}$ and $^{L}MS$ $v_{S}$ are irreducible.  For example, $SH^{\forall X.(T\rightarrow T)}$ $\Lambda X.(\lambda x:X.x)\rightarrow SH^{(T\rightarrow T)[L/X]}$ $(\Lambda X.(\lambda x:X.x))$ $\lbrace L\rbrace\rightarrow SH^{L\rightarrow L}$ $(\lambda x:L.x)$.

If it is a Scheme value contained within another boundary expression, the boundary expression reduces to the Scheme value.  For example, $SH^{T}$ $(^{T}HS$ $v_{S})\rightarrow$ $v_{S}$.

\subsection{List Types}

If the expected and actual types of a boundary are a list type, the value is either an empty list or a list construction.  If it is an empty list, the boundary reduces to the empty list.  For example, $^{[T]}HM^{[T]}$ $\mathtt{nil}^{T}$ reduces to $\mathtt{nil}^{T}$.  If it is an ML list construction crossing to Haskell, the boundary reduces to a list construction of the head and tail of the ML list construction wrapped in boundaries.  For example, $^{[T]}HM^{[T]}$ $(\mathtt{cons}$ $v_{M}^{1}$ $v_{M}^{2})$ reduces to $\mathtt{cons}$ $(^{T}HM^{T}$ $v_{M}^{1})$ $(^{[T]}HM^{[T]}$ $v_{M}^{2})$.  If it is a Haskell list construction crossing to ML, the boundary is irreducible.  Since Haskell list constructions can be recursive and therefore infinite, they canot be mechanically converted to equivalent ML list constructions.  Therefore $^{[T]}MH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2})$ is a value.  Instead, heads and tails cross to ML individually when accessed by head and tail operations.  For example, $\mathtt{tl}$ $(^{[T]}MH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2}))$ reduces to $^{T}MH^{T}$ $e_{H}^{1}$.

If the expected and actual types of a boundary are a list type and the Scheme type, respectively, the value is either an empty list or a list construction.  If it is an empty list, the boundary reduces to an empty list of the corresponding type.  For example, $^{[T]}HS$ $\mathtt{nil}$ reduces to $\mathtt{nil}^{T}$.  If it is a list construction, the boundary expression reduces to a list construction of the head and tail wrapped in boundaries.  For example, $^{[T]}HS$ $(\mathtt{cons}$ $v_{S}^{1}$ $v_{S}^{2})$ reduces to $\mathtt{cons}$ $(^{T}HS$ $v_{S}^{1})$ $(^{[T]}HS$ $v_{S}^{2})$.

If the expected and actual types of a boundary are the Scheme type and a list type, respectively, the value is either an empty list or a list construction.  If it is an empty list, the boundary reduces to an empty list.  For example, $SH^{[T]}$ $\mathtt{nil}^{T}$ reduces to $\mathtt{nil}$.  If it is an ML list construction, the boundary reduces to a list construction of the head and tail wrapped in boundaries.  For example, $SM^{[T]}$ $(\mathtt{cons}$ $v_{M}^{1}$ $v_{M}^{2})$ reduces to $\mathtt{cons}$ $(SM^{T}$ $v_{M}^{1})$ $(SM^{[T]}$ $v_{M}^{2})$.  If it is a Haskell list construction, it is irreducible for the same reason that $^{[T]}MH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2})$ is a value, as discussed above.  Therefore $SH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2})$ is a value.

\input{model/hie.tex}
\input{model/mie.tex}
\input{model/sie.tex}
\input{model/hitr.tex}
\input{model/mitr.tex}
\input{model/sitr.tex}
\input{model/hios.tex}
\input{model/mios.tex}
\input{model/sios.tex}