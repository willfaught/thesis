\chapter{Model of Computation}

Embedding server languages within client languages as expressions succinctly expresses the client-server interaction of interoperation.  Embedded server expressions evaluate to values and convert to equivalent client values.  Value conversion represents servers sending data and clients receiving data.  Since Haskell, ML, and Scheme are functional languages, extended lambda calculi naturally represent and simplify them.

Lambda calculus is a minimal model of computation that embodies the notions of function abstraction and function application.  Computations substitute function arguments for free occurrences of function parameters within function bodies.  Interoperation between two lambda calculi is expressed by embedding an expression from one language within an expression of the other language.  Embeddings use special syntactic forms called boundaries that indicate a change of language and expected (client) and actual (server) types.  Evaluation contexts determine evaluation strategies.

\section{Core Calculi}

The core calculi are the subset of the model that define the languages, but do not make provisions for interoperation.

\subsection{Haskell}

Lambda calculus is comprised of functions, variables, and function applications.  Haskell extends lambda calculus in several ways.  First, it adds natural numbers, addition and subtraction operations for natural numbers, and a condition that uses the natural number zero as true and all other natural numbers as false.

Second, it adds list constructions that contain pairs of head and tail expressions, empty lists, operations to access head and tail expressions within list constructions, a condition that uses empty lists as true and list constructions as false, and error reports for head and tail operations that operate on empty lists.

Third, it adds a static type system called System F.  System F adds types for natural numbers, lists, and functions and the expressions that contain them.  If the type of an expression is valid, it is well-typed; otherwise, it is ill-typed.  Type errors cannot occur in well-typed expressions.  Haskell does not compute ill-typed expressions.  It adds type annotations to empty lists, functions, and error reports to enable the calculation of their types.  It adds parametric polymorphism whereby the types of expressions can be parameterized by type variables and type abstractions and then instantiated with type applications.  It adds types for type variables and type abstractions.  It adds a fixed-point operation, without which Haskell could not express recursive functions and therefore would be Turing-incomplete.

Fourth, the values and evaluation contexts of Haskell conform to an extended call-by-name (lazy) evaluation strategy.

An expression is an instance of any syntactic form.  A reduction or evaluation is a step of computation that applies a rewrite rule of an operational semantics to an expression.  A value is an expression that is irreducible.  Letter subscripts of grammar non-terminals and type relations denote the language to which they belong.

Types, denoted $T$, are comprised of the natural number type, denoted $N$; type variables, denoted $X$; function types, denoted $T\rightarrow T$; universally-quantified (forall) types, denoted $\forall X.T$; and list types, denoted $[T]$.

Haskell values, denoted $v_{H}$, are comprised of natural numbers, denoted $\overline{n}$, which syntactically represents the natural number $n$; list constructions, denoted $\mathtt{cons}$ $e_{H}$ $e_{H}$; empty lists, denoted $\mathtt{nil}^{T}$; functions, denoted $\lambda x:T.e_{H}$; and type abstractions, denoted $\Lambda X.e_{H}$.

Haskell expressions, denoted $e_{H}$, are comprised of variables, denoted $x$; function applications, denoted $e_{H}$ $e_{H}$; type applications, denoted $e_{H}$ $\lbrace T\rbrace$; addition and subtraction operations, denoted $+$ $e_{H}$ $e_{H}$ and $-$ $e_{H}$ $e_{H}$, respectively; natural number conditions, denoted $\mathtt{if0}$ $e_{H}$ $e_{H}$ $e_{H}$; head and tail operations, denoted $\mathtt{hd}$ $e_{H}$ and $\mathtt{tl}$ $e_{H}$, respectively; list conditions, denoted $\mathtt{ifnil}$ $e_{H}$ $e_{H}$ $e_{H}$; fixed-point operations, denoted $\mathtt{fix}$ $e_{H}$; and error reports, denoted $\mathtt{wrong}^{T}$ string.

Haskell evaluation contexts, denoted $E_{H}$, determine the Haskell evaluation strategy by constraining which expression matches the Haskell hole.  Haskell evaluation contexts are comprised of the Haskell hole, denoted $[\,]_{H}$; left subexpressions of function applications, denoted $E_{H}$ $e_{H}$; subexpressions of type applications, denoted $E_{H}$ $\lbrace T\rbrace$; left operands of arithmetic operations, denoted $o$ $E_{H}$ $e_{H}$; right operands of arithmetic operations if left operands are values, denoted $o$ $v_{H}$ $E_{H}$; guards of natural number conditions, denoted $\mathtt{if0}$ $E_{H}$ $e_{H}$ $e_{H}$; operands of head and tail operations, denoted $f$ $E_{H}$; guards of list conditions, denoted $\mathtt{ifnil}$ $E_{H}$ $e_{H}$ $e_{H}$; and operands of fixed-point operations, denoted $\mathtt{fix}$ $E_{H}$.

Variables and type variables are unique across all languages.  Alpha conversion implicitly resolves name conflicts.

The Haskell typing relation, denoted $\Gamma\vdash_{H}e_{H}:T$, is defined by a set of typing rules.  $\Gamma\vdash_{H}e_{H}:T$ is a typing statement that asserts the type of an expression, and typing rules are implications between typing statements \cite{pierce02}.  An expression $e_{H}$ is well-typed within the context $\Gamma$ if there is some $T$ such that $\Gamma\vdash_{H}e_{H}:T$.  A context is a set of assumptions about the types of variables and the binding of type variables.  Since all programs must be closed, programs containing free variables or free type variables are ill-typed.  Adding to $\Gamma$ assumptions about $x:T$ and $X$ are denoted $\Gamma,x:T$ and $\Gamma,X$, respectively.  $\Gamma\vdash_{H}T$ is a typing statement that asserts $T$ is well-formed within $\Gamma$.  Where the context is empty, it is omitted from typing statements.

Natural numbers, addition and subtraction operations and their operands, and guards of natural number conditions have the natural number type.  Functions, left subexpressions of function applications, and operands of fixed-point operations have function types.  Type abstractions and subexpressions of type applications have forall types.  List constructions, tails of list constructions, empty lists, tail operations, operands of head and tail operations, and guards of list conditions have type list types.

Variables have the types they are assumed to have by the context.  If the context does not assume the type of a variable, the variable is free and the expression is ill-typed.  If the context does not assume the binding of a type variable, the type variable is free and the expression is ill-typed.  $T_{1}[T_{2}/X]$ denotes the substitution of $T_{2}$ for free occurrences of $X$ within $T_{1}$.  Number subscripts and superscripts of grammar symbols in typing rules denote distinct instances of them, but are absent where instances are unambigious.

Haskell computations are defined by a set of rewrite rules called an operational semantics.  A rewrite rule rewrites a reducible expression in the Haskell hole that matches its left side.  Function applications substitute function arguments for free occurrences of function parameters within function bodies.  Type applications substitute type arguments for free occurrences of type abstraction parameters within type abstraction bodies.  Addition and subtraction operations reduce to the addition and subtraction of their operands, respectively.  Natural number conditions reduce to their true or false alternatives if their guards are zero or not zero, respectively.  Head and tail operations on list constructions reduce to the heads and tails of their operands, respectively.  Head and tail operations on empty lists reduce to error reports.  List conditions reduce to their true or false alternatives if their guards are empty lists or list constructions, respectively.  Fixed-point operations reduce to their operands, which are functions, substituted for free occurrences of their function parameters within their function bodies.  Error reports reduce to errors and terminate the computation.

$e_{H}^{1}[e_{H}^{2}/x]$ denotes the substitution of $e_{H}^{2}$ for free occurrences of $x$ within $e_{H}^{1}$.  Variable instances that occur only on the right sides of rewrite rules are unique.  All rewrite rules are defined with an unspecified evaluation context $\mathscr{E}$.  The evaluation of a single language would instantiate $\mathscr{E}$ to $E_{H}$ for Haskell, to $E_{M}$ for ML, and to $E_{S}$ for Scheme.  The interoperation of languages would instantiate $\mathscr{E}$ according to the language in which programs begin and end.

\subsection{ML}

ML is identical to Haskell except that it uses an extended call-by-value (eager) evaluation strategy.  This difference affects list constructions and evaluation contexts.  Since Haskell reduces expressions only where necessary, and ML reduces expressions regardless of necessity, their definitions of values are different.  Haskell list constructions are values regardless of whether their heads and tails are values, but ML list constructions are values only where their heads and tails are values.  To reflect these differences, ML adds a list construction expression where the head and tail are expressions, denoted $\mathtt{cons}$ $e_{M}$ $e_{M}$, and changes the head and tail of its list construction value to values, denoted $\mathtt{cons}$ $v_{M}$ $v_{M}$.

ML evaluation contexts extend Haskell evaluation contexts such that all expressions are reduced and the order of evaluation is deterministic.  In addition to the Haskell definition, ML evaluation contexts are right subexpressions of function applications where left subexpressions are values, heads of list constructions, and tails of list construction where heads are values.

\subsection{Scheme}

Scheme is identical to ML except that it removes the static type system and adds a dynamic type system.  It removes all the types and type annotations for functions, empty lists, and error reports.  It removes type abstractions and type applications and the evaluation contexts, typing rules, and rewrite rules that contain them.

The dynamic type system adds type predicate expressions that determine the types of values.  $\mathtt{num?}$ $e_{S}$ determines whether $e_{S}$ is a natural number.  $\mathtt{list?}$ $e_{S}$ determines whether $e_{S}$ is a list.  $\mathtt{fun?}$ $e_{S}$ determines whether $e_{S}$ is a function.

In addition to ML evaluation contexts, Scheme evaluation contexts are the expression of type predicates, denoted $p$ $E_{S}$.

It adds a single type called The Scheme Type, $TST$.  Well-typed expressions have type $TST$, and well-typed programs are closed.

It changes the natural number condition to reduce to one if the guard is not zero, and possibly not a natural number.  It changes the list condition to reduce to one if the guard is not an empty list, and possibly not a list.  The type predicates reduce to the natural number zero if true and the natural number one if false.

\input{model/hce.tex}
\input{model/mce.tex}
\input{model/sce.tex}
\input{model/hctr.tex}
\input{model/mctr.tex}
\input{model/sctr.tex}
\input{model/hcos.tex}
\input{model/mcos.tex}
\input{model/scos.tex}

\clearpage

\section{Interoperation Calculi}

The interoperation calculi extend the core calculi with new expressions, evaluation contexts, typing rules, and rewrite rules to enable interoperation.  They add boundary expressions, which represent values with actual (server) and expected (client) types crossing from servers to clients.  Boundaries are denoted by two-letter acronyms, where the first letter names clients and the second letter names servers.  Expected types are superscripts to the left of the first letters, and actual types are superscripts to the right of the second letters.  Expressions to be reduced to values and cross languages are to the right of the letters and types, separated by a space.  For example, the expression $^{T_{1}}HM^{T_{2}}$ $e_{M}$ denotes $e_{M}$ with expected (Haskell) type $T_{1}$ and actual (ML) type $T_{2}$ crossing from ML to Haskell.  Boundaries can be nested within each other to express interoperation between more than two languages.  Since a set of $n$ interoperable languages requires $n\times(n-1)$ boundaries, this model requires six boundaries.

They add evaluation contexts for the subexpressions of boundaries ($^{T}HM^{T}$ $E_{M}$ for example).

They add typing rules for boundaries.  Boundaries are well-typed if their expected and actual types are well-formed and equivalent and the types of their subexpressions equal their actual types.  The types of boundaries are their expected types.  $TST$ is omitted from boundary notation because all well-typed Scheme expressions have type $TST$.

They add rewrite rules for every combination of boundary, expected and actual types, and syntactic forms of values.  Rewrite rules for boundaries that contain Scheme values that do not match their expected types reduce to type error reports.

The expected and actual types of boundaries determine their reduction.

\subsection{Natural Number Types}

Natural numbers do not change when they cross languages because the languages share the same number domain.  For example, $^{N}HM^{N}$ $\overline{n}$ reduces to $\overline{n}$.

\subsection{List Types}

If a boundary has expected and actual list types ($^{[T]}HM^{[T]}$ $v_{M}$ for example), the value is either an empty list ($\mathtt{nil}^{T}$ for example), a list construction ($\mathtt{cons}$ $v_{M}^{1}$ $v_{M}^{2}$ for example), or a Haskell list construction embedded in ML ($^{[T]}MH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2})$ for example).  If it is an empty list, the boundary reduces to the empty list.  For example, $^{[T]}HM^{[T]}$ $\mathtt{nil}^{T}$ reduces to $\mathtt{nil}^{T}$.  If it is a list construction crossing from ML to Haskell, the boundary reduces to a list construction of the old head and tail wrapped in boundaries.  For example, $^{[T]}HM^{[T]}$ $(\mathtt{cons}$ $v_{M}^{1}$ $v_{M}^{2})$ reduces to $\mathtt{cons}$ $(^{T}HM^{T}$ $v_{M}^{1})$ $(^{[T]}HM^{[T]}$ $v_{M}^{2})$.  If it is a list construction crossing from Haskell to ML, the boundary is irreducible.  Since Haskell list constructions can be infinite, they cannot be mechanically converted to equivalent ML list constructions.  Therefore $^{[T]}MH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2})$ is a value.  Instead, ML head and tail operations on embedded Haskell list constructions reduce to embedded heads and tails.  For example, $\mathtt{hd}$ $(^{[T]}MH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2}))$ reduces to $^{T}MH^{T}$ $e_{H}^{1}$.  If it is a Haskell list construction embedded in ML, the boundary reduces to the list construction.  For example, $^{[T]}HM^{[T]}$ $(^{[T]}MH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2}))$ reduces to $\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2}$.

If a boundary has an expected Scheme type and an actual list type ($SH^{[T]}$ $v_{H}$ for example), the value is either an empty list, a list construction, or a Haskell list construction embedded in ML ($^{[T]}MH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2})$ for example).  If it is an empty list, the boundary reduces to an empty list.  For example, $SH^{[T]}$ $\mathtt{nil}^{T}$ reduces to $\mathtt{nil}$.  If it is an ML list construction, the boundary reduces to a list construction of the old head and tail wrapped in boundaries.  For example, $SM^{[T]}$ $(\mathtt{cons}$ $v_{M}^{1}$ $v_{M}^{2})$ reduces to $\mathtt{cons}$ $(SM^{T}$ $v_{M}^{1})$ $(SM^{[T]}$ $v_{M}^{2})$.  If it is a Haskell list construction, it is irreducible for the same reason that $^{[T]}MH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2})$ is irreducible, as discussed above.  Therefore $SH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2})$ is a value.  Instead, Scheme head and tail operations on embedded Haskell list constructions reduce to embedded heads and tails.  For example, $\mathtt{hd}$ $(SH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2}))$ reduces to $SH^{T}$ $e_{H}^{1}$.  If it is a Haskell list construction embedded in ML, the boundary reduces to the list construction embedded in Scheme.  For example, $SM^{[T]}$ $(^{[T]}MH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2}))$ reduces to $SH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2})$.

If a boundary has an expected list type and an actual Scheme type ($^{[T]}HS$ $v_{S}$ for example), the value is either an empty list, a list construction, or a Haskell list construction embedded in Scheme ($SH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2})$ for example).  If it is an empty list, the boundary reduces to an empty list of the corresponding type.  For example, $^{[T]}HS$ $\mathtt{nil}$ reduces to $\mathtt{nil}^{T}$.  If it is a list construction, the boundary reduces to a list construction of the old head and tail wrapped in boundaries.  For example, $^{[T]}HS$ $(\mathtt{cons}$ $v_{S}^{1}$ $v_{S}^{2})$ reduces to $\mathtt{cons}$ $(^{T}HS$ $v_{S}^{1})$ $(^{[T]}HS$ $v_{S}^{2})$.  If it is a Haskell list construction embedded in Scheme crossing to Haskell, the boundary reduces to the list construction.  For example, $^{[T]}HS$ $(SH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2}))$ reduces to $\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2}$.  If it is a Haskell list construction embedded in Scheme crossing to ML, the boundary reduces to the list construction embedded in ML.  For example, $^{[T]}MS$ $(SH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2}))$ reduces to $^{[T]}MH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2})$.

\subsection{Function Types}

Functions cannot be mechanically converted as they cross languages because the language grammars are different, Haskell and ML do not have a reasonable equivalent for every Scheme function, and functions may behave differently with different evaluation strategies.  Instead, server functions are wrapped in client functions.  The client functions apply the server function to their arguments and produce the results as their own.  This is made possible by languages performing substitution within themselves across boundaries.

In Figure \ref{function-1}, a single boundary with an expected function type is split into two boundaries that convert the Haskell argument to an equivalent Scheme argument and the Scheme result to an equivalent Haskell result.  Every boundary with a function type is split into two boundaries in this fashion.  The Scheme-to-Haskell boundary verifies the syntactic form of its value matches its expected type.  If its value is not some list of natural numbers, it reports a type error.  If the body of the Scheme function had been $\overline{0}$ instead of $\mathtt{nil}$, the computation would have reduced to $^{[N]}HS$ $\overline{0}$ instead of $^{[N]}HS$ $\mathtt{nil}$.  Since $\overline{0}$ is not a list, $^{[N]}HS$ $\overline{0}$ reduces to $\mathtt{wrong}$ ``Not a list" to report the type error.

\input{figures/function-1.tex}

The case for higher-order functions is more complex, but straightforward.  See Figure \ref{function-2} for an example.

\input{figures/function-2.tex}

\subsection{Forall Types}

If a boundary has expected and actual forall types ($^{\forall X.T}HM^{\forall X.T}$ $v_{M}$ for example), the value is either a type abstraction ($\Lambda X.e_{M}$ for example) or a Scheme value wrapped in an inner boundary ($^{\forall X.T}MS$ $v_{S}$ for example).  If it is a type abstraction, the boundary moves inside the type abstraction and wraps the expression.  For example, $^{\forall X.T}HM^{\forall X.T}$ $\Lambda X.e_{M}$ reduces to $\Lambda X.(^{T}HM^{T}$ $e_{M})$.  If it is a Scheme value wrapped in an inner boundary, the outer boundary reduces to a new boundary bridging the outer language and Scheme that contains the Scheme value.  For example, $^{\forall X.T}HM^{\forall X.T}$ $(^{\forall X.T}MS$ $v_{S})$ reduces to $^{\forall X.T}HS$ $v_{S}$.

If a boundary has an expected forall type and an actual Scheme type ($^{\forall X.T}HS$ $v_{S}$ for example), the value is a Scheme value.  Such a boundary is irreducible because Scheme does not have type abstractions.  Therefore $^{\forall X.T}HS$ $v_{S}$ and $^{\forall X.T}MS$ $v_{S}$ are values.  Nevertheless, there are useful Scheme values that correspond to forall types, and they ought to be convertible.  If the expected forall type is instantiated and the result is not a forall type, the boundary is reducible and the Scheme value is convertible.  However, Haskell and ML preserve parametricity, and instantiating the expected forall type does nothing to prevent the Scheme value, if it is a function, from breaking parametricity once converted.

Scheme functions with expected forall types can break parametricity by using type predicates and conditions to determine their behavior by the types and values of their arguments.  Haskell and ML must wrap their arguments for these functions such that Scheme predicates and conditions cannot examine them.  Expected forall types of boundaries can be instantiated by applying those boundaries to types.  These type applications label their type arguments with unique labels, denoted $T^{a}$, before instantiating the expected forall types with them.  Boundaries with actual label types ($SH^{T^{a}}$ $e_{H}$ for example) are irreducible; Scheme type predicates and conditions cannot examine them.  Therefore $SH^{T^{a}}$ $e_{H}$ and $SM^{T^{a}}$ $v_{M}$ are values.  Scheme can return these wrapped arguments to Haskell and ML if the expected and actual types match.  For example, $^{T^{a}}HS$ $(SH^{T^{a}}$ $e_{H})$ reduces to $e_{H}$.  If they do not match, the outer boundary reduces to a parametricity error report.  See Figure \ref{forall-1} for an example.

\input{figures/forall-1.tex}

Since the Haskell and ML typing relations expect type applications to substitute types unchanged, they expect $\forall X.(X\rightarrow X)$, instantiated with $N$, to be $N\rightarrow N$.  Observe that the application of $^{\forall X.(X\rightarrow X)}HS$ $\lambda x_{1}.(\mathtt{if0}$ $x_{1}$ $\overline{1}$ $x_{1})$, which has type $\forall X.(X\rightarrow X)$, to $N$ reduces to $^{N^{a}\rightarrow N^{a}}HS$ $\lambda x_{1}.(\mathtt{if0}$ $x_{1}$ $\overline{1}$ $x_{1})$, which appears to have type $N^{a}\rightarrow N^{a}$.  The Haskell and ML typing relations resolve this conflict by removing all labels from expected and actual types before making typing judgements.  Therefore $^{N^{a}\rightarrow N^{a}}HS$ $\lambda x_{1}.(\mathtt{if0}$ $x_{1}$ $\overline{1}$ $x_{1})$ has type $N\rightarrow N$, as expected.  Rewrite rules remove labels where required to resolve type conflicts.  $T[T_{i}/T_{i}^{a}]$ denotes the replacement of every label type $T_{i}^{a}$ with its underlying type $T_{i}$ within $T$.

Scheme functions with expected forall types can also break parametricity by producing the wrong argument as their results.  Haskell and ML assume type variables for result types are instantiated along with one or more type variables for argument types.  For example, Haskell and ML assume a function with type $\forall X_{1}.(\forall X_{2}.(X_{1}\rightarrow(X_{2}\rightarrow X_{2}))$ reduces to its second argument because the second argument and the result share the same type variable.  Labels enable Haskell and ML to detect and report violations of these assumptions during run time.  Since unique labels are used for each application of a boundary to a type, they group argument and result types together.  Mismatched labels for expected and actual types of boundaries indicates that Scheme broke parametricity.  See Figure \ref{forall-2} for an example.

\input{figures/forall-2.tex}

If a boundary has an expected Scheme type and an actual forall type ($SH^{\forall X.T}$ $e_{H}$ for example), the value is either a type abstraction ($\Lambda X.e_{H}$ for example) or a Scheme value wrapped in an inner boundary ($^{\forall X.T}HS$ $v_{S}$ for example).  If the value is a type abstraction, the boundary is irreducible because Scheme does not have type abstractions.  Instead, the actual type is insantiated with, and the type abstraction is applied to, the lump type, denoted $L$.  If the result is not another type abstraction, the boundary is reducible.  Boundaries with expected lump types are irreducible; $^{L}HS$ $v_{S}$ and $^{L}MS$ $v_{S}$ are values.  Empty lists instantiated with the lump type convert as with other types because their conversions discard their type annotations.  Likewise, error reports instantiated with the lump type terminate the computation as with other types.  Polymorphic functions instantiated with the lump type satisfy the expectations of all languages because they convert to Scheme functions that can be applied to arguments of various types, but do not break parametricity.  These polymorphic functions can return their arguments to Scheme if the expected and actual types are lump types.  For example, $SH^{L}$ $(^{L}HS$ $v_{S})$ reduces to $v_{S}$.  See Figure \ref{forall-3} for an example.

\input{figures/forall-3.tex}

If it is a Scheme value wrapped in an inner boundary, the outer boundary reduces to the Scheme value.  For example, $SH^{\forall X.T}$ $(^{\forall X.T}HS$ $v_{S})$ reduces to $v_{S}$.

\input{model/hie.tex}
\input{model/mie.tex}
\input{model/sie.tex}
\input{model/hitr.tex}
\input{model/mitr.tex}
\input{model/sitr.tex}
\input{model/hios.tex}
\input{model/mios.tex}
\input{model/sios.tex}