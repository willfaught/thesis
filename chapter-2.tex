\chapter{Model of Computation}

Extended lambda calculi represent the languages.  The lambda calculus is a simple model of computation that embodies the notions of abstracting patterns into functions and applying function abstractions to concrete instances of patterns.  Computation is done by substituting function arguments for free occurrences of corresponding variables within function bodies.  Interoperation between calculi is represented by nesting one language within another as an expression embedded within special syntactic forms that indicate a change of language and expected types of expressions for either side of the boundary.

\section{Haskell}

The Haskell calculus extends the lambda calculus in several ways.  It adds a type system called System F, which provides parametric polymorphism whereby the types of terms can be parameterized and instantiated for specific types.  Types are defined explicitly by annotations for function parameters and for other terms, type abstractions for parameterizing the type of a term, and type applications for instantiating a type abstraction with a type.  The presence of explicit types enables the type of any term to be determined, which can be used to determine whether a type error would occur if the term were evaluated.  If no type errors would occur, the term is said to be well-typed; otherwise, it is said to be ill-typed or to have no type.

The addition of System F renders the calculus unequivalent to a Turing machine because recursive functions cannot have types.  To enable recursion and restore Turing equivalence, a fixed-point operator is added.  The fixed-point operator consumes a function that takes as its parameter its body and produces the body rendered recursive.

In addition, it adds natural numbers, addition and subtraction operations to combine natural numbers, and conditions to choose behavior according to natural numbers.  It adds lists, which are either a construction of head and tail expressions or empty and operations that access head and tail expressions.

Furthermore, it imposes a lazy evaluation strategy where function arguments are not evaluated before term substitution.

\subsection{Core Terms}

A term is any instance of any syntactic form.  A reduction or evaluation is a step of computation that applies a rewrite rule to a term.  A value is a term that is irreducible.  An expression is a value or a reducible term.

Haskell values, denoted $v_{H}$, are comprised of natural numbers, denoted $\overline{n}$; functions, denoted $\lambda x:T.e_{H}$; type abstractions, denoted $\Lambda X.e_{H}$; list constructions, denoted $\mathtt{cons}$ $e_{H}$ $e_{H}$; and empty lists, denoted $\mathtt{nil}^{T}$.  Haskell expressions, denoted $e_{H}$, are comprised of variables, denoted $x$; term applications, denoted $e_{H}$ $e_{H}$; type applications, denoted $e_{H}$ $\lbrace T\rbrace$; conditions, denoted $\mathtt{if0}$ $e_{H}$ $e_{H}$ $e_{H}$; arithmetic operations, denoted $+$ $e_{H}$ $e_{H}$ and $-$ $e_{H}$ $e_{H}$, accessors for list heads and tails, denoted $\mathtt{hd}$ $e_{H}$ and $\mathtt{tl}$ $e_{H}$; and fixed-point operations, denoted $\mathtt{fix}$ $e_{H}$.  Types, denoted $T$, are comprised of natural numbers, denoted $N$; type variables, denoted $X$; functions, denoted $T\rightarrow T$; universal types, denoted $\forall X.T$; and lists, denoted $[T]$.  Haskell evaluation contexts, denoted $E_{H}$, determine the evaluation strategy by constraining which term matches with the Haskell hole, denoted $[\,]_{H}$.  A Haskell evaluation context can be the Haskell hole, the left term of a term application, the left term of a type application, the guard of a condition, the left operand of an arithmetic operation, the right operand of an arithmetic operation if the left operand is a natural number, the operand of a head or tail access operation, or the operand of a fixed-point operation.  Haskell core terms are summarized in Figure \ref{hct}.

\input{model/hct.tex}

\subsection{Core Typing Rules}

\subsection{Core Operational Semantics}

\subsection{Interoperation Terms}

\subsection{Interoperation Typing Rules}

\subsection{Interoperation Operational Semantics}