\chapter{Model of Computation}

Embedding server languages within client languages as expressions succinctly expresses the client-server interaction of interoperation.  Embedded server expressions evaluate to values and convert to equivalent client values.  Value conversion represents servers sending data and clients receiving them.  Since Haskell, ML, and Scheme are functional languages, extended lambda calculi can represent them.

Lambda calculus is a minimal model of computation that embodies the notions of abstracting patterns into functions and applying function abstractions to concrete instances of patterns.  Computation is done by substituting function arguments for free occurrences of corresponding variables within function bodies.  Interoperation between lambda calculi is represented by nesting languages within languages expressions embedded within special syntactic forms that indicate a change of language and expected and actual types of values for both sides of boundaries.

\section{Core Calculi}

\subsection{Haskell}

Lambda calculus is comprised of functions, variables, and function applications.  Haskell extends lambda calculus in several ways.  First, it adds natural numbers, addition and subtraction operations for natural numbers, and a condition that uses the natural number zero as true and all other natural numbers as false.

Second, it adds list constructions containing pairs of head and tail expressions, empty lists, operations to access head and tail expressions within list constructions, a condition that uses empty lists as true and list constructions as false, and error reports for head and tail operations that operate on empty lists.

Third, it adds a static type system called System F.  System F adds types for natural numbers, lists, and functions and the expressions that contain them.  If the type of an expression is valid, it is well-typed; otherwise, it is ill-typed.  Type errors cannot occur in well-typed expressions.  Haskell does not compute ill-typed expressions.  It adds type annotations to some expressions to enable the calculation and validation of expression types.  It adds parametric polymorphism whereby the types of expressions can be parameterized by type variables and type abstractions and then instantiated with type applications.  It adds types for type variables and type abstractions.

System F renders Haskell Turing-incomplete because Haskell cannot express recursive functions.  Haskell adds a fixed-point operator to restore Turing-completeness.  The operand of the fixed-point operator is a function of a recursive function over the body of the recursive function.

Fourth, it adds evaluation contexts where appropriate according to the spirit of lazy evaluation.

An expression is an instance of any syntactic form.  A reduction or evaluation is a step of computation that applies a rewrite rule of an operational semantics to an expression.  A value is an expression that is irreducible.  Letter subscripts of grammar non-terminals and relations denote the language to which they belong.

Types, denoted $T$, are comprised of natural numbers, denoted $N$; type variables, denoted $X$; functions, denoted $T\rightarrow T$; type abstractions, denoted $\forall X.T$; and lists, denoted $[T]$.

Haskell values, denoted $v_{H}$, are comprised of natural numbers, denoted $\overline{n}$, which syntactically represents the natural number $n$; list constructions, denoted $\mathtt{cons}$ $e_{H}$ $e_{H}$; empty lists, denoted $\mathtt{nil}^{T}$; functions, denoted $\lambda x:T.e_{H}$; and type abstractions, denoted $\Lambda X.e_{H}$.

Haskell expressions, denoted $e_{H}$, are comprised of variables, denoted $x$; function applications, denoted $e_{H}$ $e_{H}$; type applications, denoted $e_{H}$ $\lbrace T\rbrace$; addition and subtraction operations, denoted $+$ $e_{H}$ $e_{H}$ and $-$ $e_{H}$ $e_{H}$, respectively; natural number conditions, denoted $\mathtt{if0}$ $e_{H}$ $e_{H}$ $e_{H}$; head and tail operations, denoted $\mathtt{hd}$ $e_{H}$ and $\mathtt{tl}$ $e_{H}$, respectively; list conditions, denoted $\mathtt{ifnil}$ $e_{H}$ $e_{H}$ $e_{H}$; fixed-point operations, denoted $\mathtt{fix}$ $e_{H}$; and error reports, denoted $\mathtt{wrong}^{T}$ string.

The Haskell evaluation context, denoted $E_{H}$, determines the Haskell evaluation strategy by constraining which expression matches the Haskell hole, denoted $[\,]_{H}$.  The Haskell evaluation context is the Haskell hole, the left expression of a function application, the left expression of a type application, the left operand of an arithmetic operation, the right operand of an arithmetic operation if the left operand is a value, the guard of a natural number condition, the operand of a head or tail operation, the guard of a list condition, or the operand of a fixed-point operation.

Variables and type variables are unique across all languages.  Alpha conversion implicitly resolves name conflicts.

The Haskell type statement $\Gamma\vdash_{H}T$ asserts the type $T$ is well-formed and contains zero or more free type variables in the context $\Gamma$.  If the type is well-formed and contains zero free type variables, the context can be omitted, denoted $\vdash_{H}T$.  The Haskell type statement $\Gamma\vdash_{H}e_{H}:T$ asserts the expression $e_{H}$ has type $T$ in the context $\Gamma$.  If $e_{H}$ contains zero free variables and $T$ is well-typed and contains zero free type variables, the context can be omitted, denoted $\vdash_{H}e_{H}:T$.  Extending an old context $\Gamma$ with type variables and variable-type associations, denoted $\Gamma,X$ and $\Gamma,x:T$, respectively, constructs a new context.  Type substitution substitutes one type, $T_{1}$, for a second type, $T_{2}$, within a third type, $T_{3}$, denoted $T_{3}[T_{1}/T_{2}]$.  Number subscripts and superscripts of grammar symbols denote distinct instances of them.

!!! TODO: check defn. of type subst above: what about only replacing free occurrences of type vars?  maybe a second defn. for Ti/Tia?
!!! TODO: add more discussion for typing rules?

Expression substitution substitutes one expression, $e_{H}^{1}$, for a variable, $x$, within a second expression, $e_{H}^{2}$, denoted $e_{H}^{2}[e_{H}^{1}/x]$.  Any instances of variables that occur only on the right side of a rewrite rule are new and unique and thus do not create a name conflict with other variables.  All rewrite rules are defined with an unspecified evaluation context $\mathscr{E}$.  The evaluation of a single language would instantiate $\mathscr{E}$ to $E_{H}$ for Haskell, to $E_{M}$ for ML, and to $E_{S}$ for Scheme.  The evaluation of multiple languages would instantiate $\mathscr{E}$ according to the language in which programs begin and end.

!!! TODO: add more discussion for OS?

\subsection{ML}

The ML calculus is identical to the Haskell calculus except that Haskell uses lazy evaluation and ML uses strict evaluation.  The difference of evaluation strategy affects list constructions and the evaluation of function arguments.  In Haskell, every list construction is a value, but its head and tail are expressions, not necessarily values, because they are not evaluated.  This follows the notion of lazy evaluation that expressions are not evaluated until they are used.  In ML, a list construction is a value only if its head and tail are also values.  This follows the notion of strict evaluation that expressions are evaluated up front despite their future utility.  To reflect these differences, the head and tail of the list construction value are changed to values, denoted $\mathtt{cons}$ $v_{M}$ $v_{M}$, and a list construction expression is added, denoted $\mathtt{cons}$ $e_{M}$ $e_{M}$.  Since heads and tails are evaluated in ML, the ML evaluation context can also be the head and tail of a list construction.  To preserve a deterministic order of evaluation on list constructions, much like arithmetic operations, the head is evaluated before the tail.  Therefore the ML evaluation context can be the tail of a list construction only if the head is an ML value.  

In addition, in Haskell, function arguments are not evaluated, but they are in ML.  Therefore the ML evaluation context can also be the right term of a term application if the left term is an ML value.

The rest is identical to Haskell.

\subsection{Scheme}

Scheme is identical to ML except it removes the static type system and adds a dynamic type system.  Those terms, type annotations for terms, evaluation contexts, and rewrite rules the static type system added to the Haskell and ML calculi are removed from the Scheme calculus.  Specifically, the terms $\Lambda X.e_{S}$, $e_{S}$ $\lbrace T\rbrace$, and $\mathtt{fix}$ $e_{S}$; the type annotation in the terms $\lambda x:T.e_{S}$ and $\mathtt{nil}^{T}$; the evaluation contexts $E_{S}$ $\lbrace T\rbrace$ and $\mathtt{fix}$ $E_{S}$; and the rewrite rules $\mathscr{E}[(\Lambda X.e_{S})$ $\lbrace T\rbrace]_{S}\rightarrow\mathscr{E}[e_{S}[T/X]]$ and $\mathscr{E}[\mathtt{fix}$ $(\lambda x:T.e_{S})]_{S}\rightarrow\mathscr{E}[e_{S}[(\mathtt{fix}$ $(\lambda x:T.e_{S}))/x]]$ are removed.

The dynamic type system provides type predicates that determine the types of values at run time and a mechanism for signaling type errors.  The expression $\mathtt{num?}$ $e_{S}$ determines if $e_{S}$ is a natural number.  The expression $\mathtt{list?}$ $e_{S}$ determines if $e_{S}$ is a list.  The expression $\mathtt{fun?}$ $e_{S}$ determines if $e_{S}$ is a function.  The expression $\mathtt{wrong}$ string signals an error with the corresponding explanation.  Scheme evaluation contexts can also be the argument of a type predicate, denoted $\mathtt{num?}$ $E_{S}$, $\mathtt{list?}$ $E_{S}$, and $\mathtt{fun?}$ $E_{S}$.

There is one Scheme type called The Scheme Type, $TST$.  Every well-typed term and subterm has type $TST$.  The purpose of Scheme types is merely to ensure that all free variables are in some context $\Gamma$.

The natural number $\overline{0}$ represents true and all other values of any type represent false.  As such, the condition expression reduces to the true alternative if the guard is $\overline{0}$ and to the false alternative otherwise.  The type predicate expressions reduce to $\overline{0}$ if the predicate is true and the natural number $\overline{1}$ if the predicate is false.  The wrong expression discards the current evaluation context and signals an error with an explanation.  Since type errors can occur at run time, rewrite rules must be added to handle such cases by signaling an an error with an explanation.

\input{model/hce.tex}
\input{model/hctr.tex}
\input{model/hcos.tex}
\input{model/mce.tex}
\input{model/mctr.tex}
\input{model/mcos.tex}
\input{model/sce.tex}
\input{model/sctr.tex}
\input{model/scos.tex}

\section{Interoperation Calculi}

The interoperation calculi extend the core calculi with new expressions, evaluation contexts, typing rules, and rewrite rules to enable language interoperation.  For each pairing of sending and receiving languages, the interoperation calculi must represent a value with an actual and expected type crossing the boundary from the sending language to the receiving language.  Boundary expressions are denoted by a two-letter acronym, where the first letter names the receiving language and the second letter names the sending language.  The expected and actual types are superscripts to the left and right of the first and second letters, respectively.  The expression to be reduced to a value and cross from the sending language to the receiving language is to the right of the letters and types and separated by a space.  For example, the expression $^{T_{1}}HM^{T_{2}}$ $e_{M}$ denotes the ML expression $e_{M}$ with the actual type $T_{2}$ and the expected type $T_{1}$ crossing the boundary from ML to Haskell.  $T_{1}$ and $T_{2}$ must be well-formed according to the Haskell and ML typing rules, respectively; $T_{1}$ must equal $T_{2}$; and $e_{M}$ must have type $T_{2}$ for $^{T_{1}}HM^{T_{2}}$ $e_{M}$ to have type $T_{1}$.  Since all well-typed Scheme expressions have type $TST$, $TST$ is omitted for expected and actual types of boundary expressions.  For each boundary expression, the interoperation calculi add rewrite rules for every combination of sending and receiving languages, expected and actual types, and syntactic form of values.  Rewrite rules for Scheme values crossing boundaries verify the syntactic forms of the values match the expected types.

[!!! add eval contexts for boundary exp exp]

\subsection{Natural Numbers}

Natural numbers remain unchanged when they cross boundaries because all of the languages have the same number domain.  For example, $^{N}HM^{N}$ $\overline{n}\rightarrow\overline{n}$.  In the cases of $^{N}HS$ $v_{S}$ and $^{N}MS$ $v_{S}$, where $v_{S}$ is not a natural number, the boundary expressions reduce to type errors that explain that the Scheme value is not a natural number.

\subsection{Functions}

Functions cannot be directly converted when they cross boundaries because each language grammar is different, Haskell and ML do not have a reasonable equivalent for every Scheme function, and functions may behave differently if they are evaluated with a different evaluation strategy.  Instead, a function from the sending language is wrapped inside a function from the receiving language with a boundary expression.  The wrapper function passes its argument across a boundary from the receiving language to the sending language.  Within the sending language, the original function is applied to the argument, and the result is passed back across a boundary to the receiving language.  The wrapper function produces the result from the sending language as its result.  To do this, a language is allowed to perform substitution within itself across boundaries.  For example, the Scheme function $\lambda x_{1}.e_{S}$ represented in Haskell with type $T_{1}\rightarrow T_{2}$ is $\lambda x_{2}:T_{1}.(^{T_{2}}HS$ $((\lambda x_{1}.e_{S})$ $(SH^{T_{1}}$ $x_{2})))$.  If the Haskell function is applied to an argument, the argument crosses the $SH^{T_{1}}$ boundary from Haskell to Scheme, the Scheme function is applied to it, and its result crosses the $^{T_{2}}HS$ boundary from Scheme back to Haskell, which becomes the result of the function application.

\subsection{Universal Types}

If the expected and actual types of a boundary expression are a universal type, the contained value is either a type abstraction or a Scheme value contained within another boundary expression.  If it is a type abstraction, $\Lambda X.e_{M}$ with type $\forall X.T$ for example, the boundary expression reduces to a type abstraction of $X$ for a boundary with expected and actual type $T$ containing $e_{M}$.  Therefore $^{\forall X.T}HM^{\forall X.T}$ $(\Lambda X.e_{M})\rightarrow\Lambda X.(^{T}HM^{T}$ $e_{M})$.  If it is a Scheme value contained within another boundary expression, $^{\forall X.T}MS$ $v_{S}$ for example, the boundary expression reduces to a new boundary expression where $v_{S}$ crosses from Scheme to Haskell with expected type $\forall X.T$ and actual type $TST$.  Therefore $^{\forall X.T}HM^{\forall X.T}$ $(^{\forall X.T}MS$ $v_{S})\rightarrow{^{\forall X.T}H}S$ $v_{S}$.

If the expected and actual types of a boundary expression are a universal type and the Scheme type, respectively, the contained value is a Scheme value.  Such a boundary expression is irreducible because Scheme does not have expressions with universal types.  Therefore $^{\forall X.T_{1}}HS$ $v_{S}$ and $^{\forall X.T_{1}}MS$ $v_{S}$ are values.  Instead, such a boundary expression can be applied to a type $T_{2}$ like a type abstraction, which could substitute the type argument $T_{2}$ for $X$ within $T_{1}$ for its expected and actual types.  However, if $T_{1}$ is a function type that contains $X$ and $v_{S}$ is a function, a safeguard must ensure that $v_{S}$ does not break the parametricity of Haskell and ML.  For example, if $T_{1}$ is $X\rightarrow X$, Haskell and ML assume $v_{S}$ is the identity function, but it may be another function that satisfies the type and thus breaks parametricity.

To ensure Scheme cannot break parametricity, the safeguard must do two things.  First, it must prevent polymorphic Scheme functions from determining their behavior by the types and values of their arguments.  Consider the following reductions, where a polymorphic Scheme function would break the parametricity of Haskell:

\begin{tabular}{ll}
& $((^{\forall X.(X\rightarrow X)}HS$ $(\lambda x_{1}.(\mathtt{if0}$ $x_{1}$ $1$ $x_{1})))$ $\lbrace N\rbrace)$ $\overline{0}$ \\
$\rightarrow$ & $(^{N\rightarrow N}HS$ $(\lambda x_{1}.(\mathtt{if0}$ $x_{1}$ $1$ $x_{1})))$ $\overline{0}$ \\
$\rightarrow$ & $(\lambda x_{2}:N.(^{N}HS$ $((\lambda x_{1}.(\mathtt{if0}$ $x_{1}$ $1$ $x_{1}))$ $(SH^{N}$ $x_{2}))))$ $\overline{0}$ \\
$\rightarrow$ & $^{N}HS$ $((\lambda x_{1}.(\mathtt{if0}$ $x_{1}$ $1$ $x_{1}))$ $(SH^{N}$ $\overline{0}))$
\end{tabular}

Next, the $SH^{N}\;\overline{0}$ boundary expression would reduce and the Haskell function argument $\overline{0}$ would cross the boundary from Haskell to Scheme and reduce to the Scheme value $\overline{0}$.  The Scheme polymorphic function can now determine the type and value of the argument and thereby break parametricity.  Therefore to preserve parametricity, $SH^{N}\;\overline{0}$ cannot be reducible, and in fact all such boundary expressions in the context of being arguments to polymorphic Scheme functions cannot be reducible as well.  Since such boundary expressions also occur for the conversion of non-polymorphic Scheme functions, such boundary expressions must be marked in such a way that they are reducible for non-polymorphic functions but irreducible for polymorphic functions.  This is done by introducing a new type called a type label, denoted $T^{a}$, and changing the type arguments to labeled types before performing the type substitution.  Even though labeled types are used, the type of the expression is still expected to be the type underlying the label, so the type of HS and MS expressions and the types of expressions within SH and SM expressions are their expected and actual types, respectively, with their labeled types replacd with their corresponding underlying types, denoted $T[T_{i}/T_{i}^{a}]$.  Furthermore, since arguments may be returned, there has to be a way to reduce the nested HS and SH boundaries to retrieve the Haskell value.  Therefore the rewrite rule $\mathscr{E}[^{T^{a}}HS$ $(SH^{T^{a}}$ $e_{H})\rightarrow\mathscr{E}[e_{H}]$ is added.

Second, it must verify that the same argument corresponds to every instantiation of $X$ within $T_{1}$.  Otherwise, it is possible for a Scheme function with type $\forall X_{1}.(\forall X_{2}.(X_{1}\rightarrow X_{2}\rightarrow X_{1}))$ and instantiated with $N$ and again with $N$ to return the second argument and not the first as required by parametricity.  Therefore every type label used for type substitutions must be unique and the type labels of nested HS and SH and MS and SM expressions must match up.  Otherwise, an error is signaled to indicate that parametricity was broken.

Even if $T_{1}$ is not a function type, the type labels are still used in case a function type is contained by it.

If the expected and actual types of a boundary expression are the Scheme type and a universal type, respectively, the contained value is either a type abstraction or a Scheme value contained within another boundary expression.

If it is a type abstraction, $\Lambda X.e_{H}$ with type $\forall X.T$ for example, it may contain parametrically polymorphic functions of types containing $X$.  Since those functions are parametrically polymorphic, they cannot examine the types or values of their arguments.  Therefore Scheme arguments for these functions cannot cross the boundary to Haskell and ML.  In addition, the function types must be instantiated with a type that would enable them to accept any Scheme argument.  The lump type $L$ is added to be used in these situations.  $^{L}HS$ $v_{S}$ and $^{L}MS$ $v_{S}$ are irreducible.  For example, $SH^{\forall X.(T\rightarrow T)}$ $\Lambda X.(\lambda x:X.x)\rightarrow SH^{(T\rightarrow T)[L/X]}$ $(\Lambda X.(\lambda x:X.x))$ $\lbrace L\rbrace\rightarrow SH^{L\rightarrow L}$ $(\lambda x:L.x)$.

If it is a Scheme value contained within another boundary expression, the boundary expression reduces to the Scheme value.  For example, $SH^{T}$ $(^{T}HS$ $v_{S})\rightarrow$ $v_{S}$.

\subsection{Lists}

If the expected and actual types of a boundary expression are a list type, the contained value is either an empty list or a list construction.  If it is an empty list, the boundary expression reduces to the empty list.  For example, $^{[T]}HM^{[T]}$ $\mathtt{nil}^{T}$ reduces to $\mathtt{nil}^{T}$.  If it is an ML list construction crossing to Haskell, the boundary expression reduces to a list construction where the head and tail are the head and tail of the ML list construction wrapped in boundary expressions, respectively.  For example, $\mathtt{cons}$ $v_{M}^{1}$ $v_{M}^{2}$ with type $[T]$ would reduce to $\mathtt{cons}$ $(^{T}HM^{T}$ $v_{M}^{1})$ $(^{[T]}HM^{[T]}$ $v_{M}^{2})$.  If it is a Haskell list construction crossing to ML, the boundary expression should be irreducible.  Since Haskell list constructions are values, they can be recursive and therefore infinite in length.  Converting a list construction from Haskell to ML like a list construction is converted from ML to Haskell would reduce the tail until it is a value.  If the list construction were infinite, the tail may reduce to the list construction, and thus never reduce to a value, and the computation would loop forever.  Therefore $^{[T]}MH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2})$ is a value.

If the expected and actual types of a boundary expression are a list type and the Scheme type, respectively, the contained value is either an empty list or a list construction.  If it is an empty list, the boundary expression reduces to an empty list of the corresponding type.  For example, $^{[T]}HS$ $\mathtt{nil}$ reduces to $\mathtt{nil}^{T}$.  If it is a list construction, the boundary expression reduces to a list construction where the new head and tail are the old head and tail wrapped in boundary expressions, respectively.  For example, $^{[T]}HS$ $\mathtt{cons}$ $v_{S}^{1}$ $v_{S}^{2}$ reduces to $\mathtt{cons}$ $(^{T}HS$ $v_{S}^{1})$ $(^{[T]}HS$ $v_{S}^{2})$.

If the expected and actual types of a boundary expression are the Scheme type and a list type, respectively, the contained value is either an empty list or a list construction.  If it is an empty list, the boundary expression reduces to an empty list.  For example, $SH^{[T]}$ $\mathtt{nil}^{T}$ reduces to $\mathtt{nil}$.  If it is an ML list construction, the boundary expression reduces to a list construction where the new head and tail are the old head and tail wrapped in boundary expressions, respectively.  For example, $SM^{[T]}$ $v_{M}^{1}$ $v_{M}^{2}$ reduces to $\mathtt{cons}$ $(SM^{T}$ $v_{M}^{1})$ $(SM^{[T]}$ $v_{M}^{2})$.  If it is a Haskell list construction, it should be irreducible for the same reason that $^{[T]}MH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2})$ is a value, as discussed above.  Therefore $SH^{[T]}$ $(\mathtt{cons}$ $e_{H}^{1}$ $e_{H}^{2})$ is a value.

\input{model/hie.tex}
\input{model/hitr.tex}
\input{model/hios.tex}
\input{model/mie.tex}
\input{model/mitr.tex}
\input{model/mios.tex}
\input{model/sie.tex}
\input{model/sitr.tex}
\input{model/sios.tex}