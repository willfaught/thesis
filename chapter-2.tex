\newcommand{\haskell}{Haskell model\xspace}
\newcommand{\ml}{ML model\xspace}
\newcommand{\scheme}{Scheme model\xspace}

\newcommand{\haskellml}{Haskell and ML models\xspace}

\newcommand{\articlehaskell}[1]{#1 \haskell}
\newcommand{\articleml}[1]{#1 \ml}
\newcommand{\articlescheme}[1]{#1 \scheme}

\newcommand{\articlehaskellml}[1]{#1 \haskellml}

\newcommand{\thehaskell}{\articlehaskell{the}}
\newcommand{\Thehaskell}{\articlehaskell{The}}
\newcommand{\theml}{\articleml{the}}
\newcommand{\Theml}{\articleml{The}}
\newcommand{\thescheme}{\articlescheme{the}}
\newcommand{\Thescheme}{\articlescheme{The}}

\newcommand{\thehaskellml}{\articlehaskellml{the}}
\newcommand{\Thehaskellml}{\articlehaskellml{The}}

\newcommand{\hastype}[1]{has the type #1}
\newcommand{\havetype}[1]{have the type #1}

\chapter{Model of Computation}

The model of computation is based on that of Matthews and Findler \ref{matthews07}. Their model consists of two simple models, one representing ML and the other Scheme.

The ML model is a simply-typed lambda calculus extended with parametric polymorphism called System F. The substitution semantics by which type abstractions are applied means the ML model has parametricity, which is a property that ensures that programs behave the same regardless of the types applied to by type abstractions.  The ML model introduces new expressions, type abstractions and type applications, to express parametric polymorphism, and new types, type variables and forall types, for them. The ML model uses an eager evaluation strategy.

The Scheme model is an extended untyped lambda calculus using an eager evaluation strategy. Value predicates enable ad-hoc polymorphism. Uses a simple type system to check for free variables.

To this mix we introduce a Haskell model identical to the ML model, except it uses a lazy evaluation strategy.

The definitions of the Haskell, ML, and Scheme models begin in figures \ref{hg}, \ref{mg}, and \ref{sg}.

Expressions are written \varexp, types are written \varty, forced values are written \varvalf, unforced values are written \varvalu, forced evaluation contexts are written \varconf, and unforced evaluation contexts are written \varconu. Symbols that represent grammar non-terminals or relations typically have letter subscripts that specify a model.

\Thehaskellml have static type systems that use typing environments, written \env, and typing relations, written \jud. Typing judgements for expressions are written \jude{\env}{\jud}{\varexp}{\varty}, where \varexp is bound in \env and has the type \varty. Typing judgements for types are written \judt{\env}{\jud}{\varty} and mean \varty is bound in \env. Extended typing environments are written \envexte{\env}{\varvar}{\varty} for variables and \envextt{\env}{\tyvar} for type variables. Typing environments are omitted where empty. \Thescheme uses a simple type system to ensure no free variables. Every well-typed \scheme expression \hastype{\tytst}. Type substitution within types is written \tysubst{\formvar{x}}{\formvar{y}}{\formvar{z}}, where the type \formvar{y} is substituted for free occurrences of the type variable \formvar{z} in the type \formvar{x}.

TODO: opsem

Expression and type substitutions within expressions are written like type substitutions within types.

\section{Natural Numbers}

Natural number expressions are written \expnum{\varnum}, which syntactically denotes the natural number \varnum. Natural numbers \havetype{\tynum} for \thehaskellml. The arithmetic operations \expadd{\varexph}{\varexph} and \expsub{\varexph}{\varexph}, their operands, and \theml counterparts \havetype{\tynum}. In \thescheme, if either operand of an arithmetic expression is not a natural number, the operation reduces to an error, written \expwrongd{\errnum}. Conditional expressions test whether an expression is the natural number \expnum{0}; if it is, it reduces to the first alternative, otherwise it reduces to the second alternative. In \thehaskellml, conditional test expressions \havetype{\tynum} and the alternative expressions have the same type. \Thescheme has predicates that determine whether values are functions, lists, empty lists, or natural numbers, written \exppfun{\varexps}, \expplist{\varexps}, \exppnull{\varexps}, and \exppnum{\varexps}. Predicates reduce to \expnum{0} if true and \expnum{1} if false.

\section{Lists}

TODO

\section{Functions}

TODO

\section{Types}

TODO

\section{Interoperation}

TODO

\clearpage

\input{model/haskell/grammar.tex}

\clearpage

\input{model/haskell/typing-rules.tex}

\clearpage

\input{model/haskell/operational-semantics/haskell.tex}

\clearpage

\input{model/haskell/operational-semantics/ml.tex}

\clearpage

\input{model/haskell/operational-semantics/scheme.tex}

\clearpage

\input{model/ml/grammar.tex}

\clearpage

\input{model/ml/typing-rules.tex}

\clearpage

\input{model/ml/operational-semantics/ml.tex}

\clearpage

\input{model/ml/operational-semantics/haskell.tex}

\clearpage

\input{model/ml/operational-semantics/scheme.tex}

\clearpage

\input{model/scheme/grammar.tex}

\clearpage

\input{model/scheme/typing-rules.tex}

\clearpage

\input{model/scheme/operational-semantics/scheme.tex}

\clearpage

\input{model/scheme/operational-semantics/haskell.tex}

\clearpage

\input{model/scheme/operational-semantics/ml.tex}

\clearpage

\input{model/unbrand.tex}

\input{model/equality.tex}