\chapter{Model of Computation}

Extended lambda calculi represent the languages.  The lambda calculus is a simple model of computation that embodies the notions of abstracting patterns into functions and applying function abstractions to concrete instances of patterns.  Computation is done by substituting function arguments for free occurrences of corresponding variables within function bodies.  Interoperation between calculi is represented by nesting one language within another as an expression embedded within special syntactic forms that indicate a change of language and expected types of expressions for either side of the boundary.

\section{Core Model}

\subsection{Haskell}

The Haskell calculus extends the lambda calculus in several ways.  It adds a type system called System F, which provides parametric polymorphism whereby the types of terms can be parameterized and instantiated for specific types.  Types are defined explicitly by annotations for function parameters and for other terms, type abstractions for parameterizing the type of a term, and type applications for instantiating a type abstraction with a type.  The presence of explicit types enables the type of any term to be determined, which can be used to determine whether a type error would occur if the term were evaluated.  If no type errors would occur, the term is said to be well-typed; otherwise, it is said to be ill-typed or to have no type.

The addition of System F renders the calculus unequivalent to a Turing machine because recursive functions do not have types.  To enable recursion and restore Turing equivalence, a fixed-point operator is added.  The fixed-point operator consumes a function that takes as its parameter its body and produces the body rendered recursive.

In addition, it adds natural numbers, addition and subtraction operations to combine natural numbers, and conditions to choose behavior according to natural numbers.  It adds lists, which are either a construction of head and tail expressions or empty and operations that access head and tail expressions.

Furthermore, it imposes a lazy evaluation strategy where function arguments are not evaluated before term substitution.

An expression is an instance of any syntactic form.  A reduction or evaluation is a step of computation that applies a rewrite rule to an expression.  A value is an instance of a syntactic form that is irreducible.  Letter subscripts of grammar non-terminals denote the language to which they belong.

Haskell values, denoted $v_{H}$, are comprised of natural numbers, denoted $\overline{n}$, which syntactically represents the natural number $n$; functions, denoted $\lambda x:T.e_{H}$; type abstractions, denoted $\Lambda X.e_{H}$; list constructions, denoted $\mathtt{cons}$ $e_{H}$ $e_{H}$; and empty lists, denoted $\mathtt{nil}^{T}$.  Haskell expressions, denoted $e_{H}$, are comprised of variables, denoted $x$; term applications, denoted $e_{H}$ $e_{H}$; type applications, denoted $e_{H}$ $\lbrace T\rbrace$; conditions, denoted $\mathtt{if0}$ $e_{H}$ $e_{H}$ $e_{H}$; arithmetic operations, denoted $+$ $e_{H}$ $e_{H}$ and $-$ $e_{H}$ $e_{H}$, list head and tail accessor operations, denoted $\mathtt{hd}$ $e_{H}$ and $\mathtt{tl}$ $e_{H}$; and fixed-point operations, denoted $\mathtt{fix}$ $e_{H}$.  Types, denoted $T$, are comprised of natural numbers, denoted $N$; type variables, denoted $X$; functions, denoted $T\rightarrow T$; universal types, denoted $\forall X.T$; and lists, denoted $[T]$.  Haskell evaluation contexts, denoted $E_{H}$, determine the evaluation strategy by constraining which term matches with the Haskell hole, denoted $[\,]_{H}$.  A Haskell evaluation context can be the Haskell hole, the left term of a term application, the left term of a type application, the guard of a condition, the left operand of an arithmetic operation, the right operand of an arithmetic operation if the left operand is a natural number, the operand of a head or tail access operation, or the operand of a fixed-point operation.  Haskell core terms are summarized in Figure \ref{hct}.

\input{model/hct.tex}

All variables and type variables in all languages must be unique.  Alpha conversion is implicitly used to resolve name conflicts.

Number superscripts of grammar non-terminals denote individual instances of them.

A Haskell type statement can assert a type $T$ is well-formed and contains zero or more free type variables that are in some context $\Gamma$, denoted $\Gamma\vdash_{H}T$.  If a type $T$ is well-formed but contains no free type variables, the context can be omitted, denoted $\vdash_{H}T$.  It can also assert the type $T$ of a term $e_{H}$, denoted $\Gamma\vdash_{H}e_{H}:T$.  A new context can be constructed from an old context $\Gamma$ by extending it with type variables and variable-type associations, denoted $\Gamma,X$ and $\Gamma,x:T$, respectively.  The letter subscript of the type judgment symbol $\vdash$ indicates the typing rules of which language to use.  Type substitution substitutes one type for a second type within a third type, denoted $T_{3}[T_{1}/T_{2}]$.  The Haskell core typing rules are in Figure \ref{hctr}.

\input{model/hctr.tex}

Expression substitution substitutes one expression, $e_{H}^{1}$, for a variable, $x$, within a second expression, $e_{H}^{2}$, denoted $e_{H}^{2}[e_{H}^{1}/x]$. All rewrite rules are defined with an unspecified evaluation context $\mathscr{E}$.  The evaluation of a single language would instantiate $\mathscr{E}$ to $E_{H}$ for Haskell, to $E_{M}$ for ML, and to $E_{S}$ for Scheme.  The evaluation of multiple languages would instantiate $\mathscr{E}$ according to the language in which programs begin and end.  The Haskell core operational semantics are in Figure \ref{hcos}.

\input{model/hcos.tex}

\subsection{ML}

The ML calculus is identical to the Haskell calculus except that Haskell uses lazy evaluation and ML uses strict evaluation.  The difference of evaluation strategy affects list constructions and the evaluation of function arguments.  In Haskell, every list construction is a value, but its head and tail are expressions, not necessarily values, because they are not evaluated.  This follows the notion of lazy evaluation that expressions are not evaluated until they are used.  In ML, a list construction is a value only if its head and tail are also values.  This follows the notion of strict evaluation that expressions are evaluated up front despite their future utility.  To reflect these differences, the head and tail of the list construction value are changed to values, denoted $\mathtt{cons}$ $v_{M}$ $v_{M}$, and a list construction expression is added, denoted $\mathtt{cons}$ $e_{M}$ $e_{M}$.  Since heads and tails are evaluated in ML, the ML evaluation context can also be the head and tail of a list construction.  To preserve a deterministic order of evaluation on list constructions, much like arithmetic operations, the head is evaluated before the tail.  Therefore the ML evaluation context can be the tail of a list construction only if the head is an ML value.  

In addition, in Haskell, function arguments are not evaluated, but they are in ML.  Therefore the ML evaluation context can also be the right term of a term application if the left term is an ML value.

The rest is identical to Haskell.  The ML core terms are in Figure \ref{mct}.  The ML typing rules are in Figure \ref{mctr}.  The ML core operational semantics are in Figure \ref{mcos}.

\input{model/mct.tex}
\input{model/mctr.tex}
\input{model/mcos.tex}

\subsection{Scheme}

Scheme is identical to ML except it removes the static type system and adds a dynamic type system.  Those terms, type annotations for terms, evaluation contexts, and rewrite rules the static type system added to the Haskell and ML calculi are removed from the Scheme calculus.  Specifically, the terms $\Lambda X.e_{S}$, $e_{S}$ $\lbrace T\rbrace$, and $\mathtt{fix}$ $e_{S}$; the type annotation in the terms $\lambda x:T.e_{S}$ and $\mathtt{nil}^{T}$; the evaluation contexts $E_{S}$ $\lbrace T\rbrace$ and $\mathtt{fix}$ $E_{S}$; and the rewrite rules $\mathscr{E}[(\Lambda X.e_{S})$ $\lbrace T\rbrace]_{S}\rightarrow\mathscr{E}[e_{S}[T/X]]$ and $\mathscr{E}[\mathtt{fix}$ $(\lambda x:T.e_{S})]_{S}\rightarrow\mathscr{E}[e_{S}[(\mathtt{fix}$ $(\lambda x:T.e_{S}))/x]]$ are removed.

The dynamic type system provides type predicates that determine the types of values at run time and a mechanism for signaling type errors.  The expression $\mathtt{nat?}$ $e_{S}$ determines if $e_{S}$ is a natural number.  The expression $\mathtt{list?}$ $e_{S}$ determines if $e_{S}$ is a list.  The expression $\mathtt{proc?}$ $e_{S}$ determines if $e_{S}$ is a function.  The expression $\mathtt{wrong}$ string signals an error with the corresponding explanation.  Scheme evaluation contexts can also be the argument of a type predicate, denoted $\mathtt{nat?}$ $E_{S}$, $\mathtt{list?}$ $E_{S}$, and $\mathtt{proc?}$ $E_{S}$.  The Scheme core terms and evaluation contexts are in Figure \ref{sct}.

\input{model/sct.tex}

There is one Scheme type called The Scheme Type, $TST$.  Every well-typed term and subterm has type $TST$.  The purpose of Scheme types is merely to ensure that all free variables are in some context $\Gamma$.  The Scheme core typing rules are in Figure \ref{sctr}.

\input{model/sctr.tex}

The natural number $\overline{0}$ represents true and all other values of any type represent false.  As such, the condition expression reduces to the true alternative if the guard is $\overline{0}$ and to the false alternative otherwise.  The type predicate expressions reduce to $\overline{0}$ if the predicate is true and the natural number $\overline{1}$ if the predicate is false.  The wrong expression discards the current evaluation context and signals an error with an explanation.  Since type errors can occur at run time, rewrite rules must be added to handle such cases by signaling an an error with an explanation.  The Scheme core operational semantics are in Figure \ref{scos}.

\input{model/scos.tex}

\section{Interoperation Model}

