\chapter{Proof of Type Soundness}

% TODO: Well-typed terms are closed, no need to specify both.

Proving the progress of expressions and the preservation of types proves the type soundness of the model of computation.  Progress ensures that a well-typed, closed expression is either an unforced value, reducible to another expression, or reducible to an error.  Preservation ensures that if a well-typed expression reduces to another expression, the other expression is well-typed and has the same type.  The proof extends the proof by Kinghorn \cite{kinghorn07}, which was based on proofs by Pierce \cite{pierce02} and Matthews and Findler \cite{matthews07}.  Cases common to two or more languages are elided for brevity.

\section{Proof of Expression Progress}

Progress will be proven by structural induction on a well-typed, closed expression of each syntactic form.  In each case, the expression will be proven to be either an unforced value, reducible to another expression, or reducible to an error.  The reduction of a subexpression is the reduction of its parent expression.  If a subexpression reduces to an error, its parent expression reduces to the error.  In some cases, the syntactic form of a subexpression must be determined to reduce its parent expression.  Determining the unique type of a subexpression determines its syntactic form.

\input{proof/progress/inversion.tex}

\input{proof/progress/uniqueness-of-types.tex}

\input{proof/progress/canonical-forms.tex}

\input{proof/progress/haskell.tex}

\input{proof/progress/ml.tex}

\input{proof/progress/scheme.tex}

\section{Proof of Type Preservation}

Preservation will be proven by cases on the reduction rules.  In each case, the right side will be proven to be well-typed and have the same type as the left side.  Lemmas \ref{leminv} and \ref{lemuni} determine the types of the left side and its subexpressions and the type of the right side.  Some reduction rules use expression and type substitutions.

If \first{\varexph} is substituted for free occurrences of \first{\varvarh} within \second{\varexph} and \first{\varexph} and \first{\varvarh} have the same type then the result has the same type as \second{\varexph}.

\input{proof/preservation/expression-substitution.tex}

If \first{\vartyh} is substituted for free occurrences of \first{\tyvarh} within \first{\varexph} of type \second{\vartyh}, the type of the result is \first{\vartyh} substituted for free occurrences of \tyvarh within \second{\vartyh}.

\input{proof/preservation/type-substitution.tex}

\input{proof/preservation/evaluation-context.tex}

\input{proof/preservation/haskell.tex}

\input{proof/preservation/ml.tex}

\input{proof/preservation/scheme.tex}
