\chapter{Implementation of the Model}

The model was implemented in the DrScheme integrated development environment.  Languages are separated into modules that export sets of definitions for the other languages to import.  Haskell and ML modules are written in subsets of their real syntaxes and compile to equivalent Scheme modules.  Scheme modules are written in a subset of their real syntax.  Type soundness is violated if Scheme modules use language constructs (variable mutation, for example) or export values (non-integer numbers, for example) not supported by the system of interoperation.  Haskell can import ML and Scheme exports, ML can import Scheme exports, and Scheme can import Haskell exports.  Haskell and ML use let-polymorphism instead of System F and use type reconstruction.  All languages use integers as their number domain.  In addition to the model, all languages have boolean values and operations, multiplication and division operations, and strings.  Haskell and Scheme have user-defined composite data types.  The ML implementation extends the implementation by Kinghorn \cite{kinghorn07}.

Languages interoperate by importing exports from other modules.  Importation expressions specify the names and types of exports and evaluate to them.  The Haskell expressions \texttt{:ml type "name"} and \texttt{:scheme type "name"} import ML and Scheme exports, respectively, where \texttt{type} is the expected type of the export and \texttt{name} is the export name.  The ML expression \texttt{name :G type} imports Scheme exports.  The Scheme expression \texttt{(:haskell "name" "type")} imports Haskell exports.  For example, \texttt{(:scheme "a $\rightarrow$ a" "identity") 0} imports the Scheme identity function to Haskell and applies it to zero.

The importation expressions verify that expected types match actual types.  The actual types of Haskell and ML imports can be validated immediately because their modules provide the types of their exports.  The actual types of Scheme imports are determined and validated during run time by contracts \cite{findler02} that are implemented by a standard library.  The contracts also blame the language at fault for a type error \cite{findler02}.  If the actual type of a Scheme value does not match its expected type, Haskell or ML is at fault.  If the actual type of a Haskell or ML value does not match its expected type, Scheme is at fault.  If Scheme applies a Haskell or ML function to an argument of the wrong type, Scheme is at fault.  Haskell and ML cannot apply a Scheme function to an argument of the wrong type because the application would be ill-typed.