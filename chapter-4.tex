\chapter{Related Work}

This work extends the work of Kinghorn \cite{kinghorn07} by adding Haskell and lists to his model of computation, his proof of type soundness, and his implementation of the model.  Kinghorn extended the work of Matthews and Findler \cite{matthews07} by adding parametric polymorphism and parametricity to their model of computation, providing a more thorough proof of its type soundness, and implementing it with a fully-featured Scheme and a subset of Objective Caml, a dialect of ML.

Guha et al. \cite{guha07} describe a system of parametric polymorphic contracts for higher-order functions that assign blame for contract violations and protect parametricity.  The system both ensures function arguments match the contract parameters and prevents functions from examining the types and values of their arguments. This work uses two separate mechanisms, boundary expressions and label types, to achieve the same result.

Perhaps the most mainstream systems of interoperation are the Common Object Request Broker Architecture (CORBA), the Component Object Model (COM), and the .NET Framework, yet not one of them supports interoperation between Haskell, ML, and Scheme as this work does.  CORBA, COM, and the .NET Framework support the interoperation of static and dynamic type systems and strict evaluation, but not higher-order functions, parametric polymorphism, parametricity, or lazy evaluation \cite{omg04} \cite{microsoft07} \cite{ecma06}.

Tobin-Hochstadt and Felleisen \cite{tobin-hochstadt06} describe a system of mechanically translating programs written in a dynamically-typed language to an equivalent form in a similar, statically-typed language.  The system has higher-order functions, static and dynamic type systems, and strict evaluation, but not parametric polymorphism, parametricity, or lazy evaluation.  The system enables the interoperation of higher-order functions, dynamic type systems, and strict evaluation, but not parametric polymorphism, parametricity, static type systems, or lazy evaluation.  It uses contracts for higher-order functions to assign blame to languages for type errors, which this model does not do.

Henglein and Rehof \cite{henglein95} describe a system of polymorphic type inference for Scheme that infers types and run-time type operations, thereby giving a high-level translation from Scheme to ML.  ML programs cannot be translated to equivalent Scheme programs.  The system has higher-order functions, parametric polymorphism, parametricity, static and dynamic type systems, and strict evaluation, but not lazy evaluation.  The system enables the interoperation of higher-order functions, dynamic type systems, and strict evaluation, but not parametric polymorphism, parametricity, static type systems, or lazy evaluation.

Benton \cite{benton05} describes a system of embedding dynamically-typed languages within the statically-typed language ML and projecting dynamically-typed values back into ML.  The system has higher-order functions, parametric polymorphism, parametricity, static and dynamic type systems, and strict evaluation, but does not have lazy evaluation.  The system enables the interoperation of higher-order functions, parametric polymorphism, static and dynamic type systems, and strict evaluation, but not parametricity or lazy evaluation.