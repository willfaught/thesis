\chapter{Implementation of the Model}

The model of computation defined above was implemented in the DrScheme integrated development environment.  Haskell and ML modules are written in subsets of their real syntaxes and compiled to Scheme modules.  Scheme modules are written with the Scheme language supported by the Scheme compiler of DrScheme.  A module defined in a particular language exports sets of declarations for the other languages and only imports sets of declarations from other modules meant only for its language.  Haskell can import ML and Scheme expressions, ML can import Scheme expressions, and Scheme can import Haskell expressions.  Haskell and ML use a form of type reconstruction called let-polymorphism instead of the explicit type system System F.  The domain of numbers for all languages is integers.  All languages have boolean values and operations, additional arithmetic operations, and composite data.  The majority of the ML implementation was taken from Kinghorn \ref{TODO: cite kinghorn}.

\section{Importation Syntax}

The model expressed language interoperation through nesting languages within each other as expressions.  Real-world code libraries interoperate through interfaces.  In the implementation, modules are the code libraries of interest.  Languages interoperate by importing a declaration exported by a module by specifying its name and type.  The Haskell syntax that imports ML and Scheme expressions is \texttt{:ml type "name"} and \texttt{:scheme type "name"}, respectively, where \texttt{type} and \texttt{name} are the types and names of the expressions, respectively.  The ML syntax that imports Scheme expressions is \texttt{name :G type}.  The Scheme syntax that imports Haskell expressions is \texttt{(:haskell name type)}.  For example, \texttt{(:scheme a $\rightarrow$ a "identity") 0} imports the Scheme identity function to Haskell and applies it to zero.

\section{Importation Type Verification}

The Haskell import expressions, the ML import expression for Scheme, and the Scheme import expression for Haskell verify the expected types match the actual types.  Where expressions from Haskell and ML are imported, their actual types can be checked immediately because Haskell and ML modules export the types of their exported declarations for import verification.  Where Scheme expressions are imported, their actual types can be checked only if they are not functions.  If they are functions, a DrScheme library that implements contracts for higher-order functions is used to delay the verifications of their types.

Contracts are the mechanism that verifies values crossing boundaries match their expected types.  The library also provides a mechanism for assigning blame \ref{TODO: cite contracts} to languages for type errors to indicate which is at fault.  If a Scheme value does not match its expected type, Scheme is at fault.  If an ML value does not match its expected type, ML is at fault.  If Scheme applies an ML function to the wrong value, Scheme is at fault.  ML cannot apply a Scheme function to the wrong type because such a function application expression would be ill-typed.

\section{Limiting Scheme}

The real-world Scheme of DrScheme represents Scheme within the system of interoperation.  The real-world Scheme has language constructs not supported or allowed by Haskell and ML.  Therefore Scheme modules are presumed to use only a subset of the features of Scheme that are compatible with Haskell and ML.  For example, a Scheme module could use side effects to break parametricity by determining the behavior of a function by the state of a global variable.