\section{Introduction}

Programmers forgo existing solutions to problems in other programming languages where software interoperation proves too cumbersome; they remake solutions, rather than reuse them. To facilitate reuse, interoperation must resolve incompatible language features transparently at the boundaries between languages. To address part of this problem, this paper presents a model of computation that resolves lazy and eager evaluation strategies.

Languages are normally independent, as in figure \ref{figsim}. Matthews and Findler \cite{matthews07} approached interoperation by tying languages together with boundary expressions, as in figure \ref{figtie}, where $\mathtt{ab} \; b$ and $\mathtt{ba} \; a$ are the boundary expressions. Expressions of one language are embedded in boundaries of another language. Embedding an expression represents the exchange of the expression from the inner language to the outer language.

\begin{figure}[htb]
\onehalfspacing
\centering
\begin{tabular}{c}
$a \; = \; x_a \; | \; \lambda x_a.a \; | \; a \; a$ \\
$b \; = \; x_b \; | \; \lambda x_b.b \; | \; b \; b$ \\
\end{tabular}
\caption{Two simple languages.}
\label{figsim}
\end{figure}

\begin{figure}[htb]
\onehalfspacing
\centering
\begin{tabular}{c}
$a \; = \; x_a \; | \; \lambda x_a.a \; | \; a \; a \; | \; \mathtt{ab} \; b$ \\
$b \; = \; x_b \; | \; \lambda x_b.b \; | \; b \; b \; | \; \mathtt{ba} \; a$ \\
\end{tabular}
\caption{Two simple languages tied together with boundaries.}
\label{figtie}
\end{figure}

Matthews and Findler used evaluation contexts to enable error states in their languages whereby on an error the entire program at that moment is discarded and replaced with an error. With evaluation contexts, every reduction rule is a whole-program transformation with a focus on the reducible expression and a reference to the enclosing evaluation context (the expression outside the reducible expression). Reduction rules can either replace the focused reducible expression within the context of the containing program, or discard the evaluation context and reduce to something else like an error.

\begin{figure}[htb]
\onehalfspacing
\centering
\begin{tabular}{c}
$e \; = \; x \; | \; v \; | \; e \; e$ \\
$v \; = \; \lambda x.e$ \\
$(\lambda x.e) \; v \; \rightarrow e[v/x]$ \\
$e \; \rightarrow \; e' \; \Rightarrow \; e \; e'' \; \rightarrow \; e' \; e''$ \\
$e \; \rightarrow \; e' \; \Rightarrow \; v \; e \; \rightarrow \; v \; e'$ \\
\end{tabular}
\caption{Reduction relation defined by inference rules.}
\label{figinf}
\end{figure}

\begin{figure}[htb]
\onehalfspacing
\centering
\begin{tabular}{c}
$e \; = \; x \; | \; v \; | \; e \; e$ \\
$v \; = \; \lambda x.e$ \\
$E \; = \; [\,] \; | \; E \; e \; | \; v \; E$ \\
$E[(\lambda x.e) \; v] \; \rightarrow E[e[v/x]]$ \\
\end{tabular}
\caption{Reduction relation defined by evaluation contexts.}
\label{figcon}
\end{figure}

\begin{figure}[htb]
\onehalfspacing
\centering
\begin{tabular}{c}
$a \; = \; x_a \; | \; \lambda x_a.a \; | \; a \; a \; | \; \mathtt{ab} \; b$ \\
$b \; = \; x_b \; | \; v \; | \; b \; b \; | \; \mathtt{ba} \; a$ \\
$v \; = \; \lambda x_b.b$ \\
$E_a \; = \; [\,]_a \; | \; E_a \; a \; | \; \mathtt{ab} \; E_b$ \\
$E_b \; = \; [\,]_b \; | \; E_b \; b \; | \; v \; E_b \; | \; \mathtt{ba} \; E_a$ \\
$E[(\lambda x_a.a) \; a']_a \; \rightarrow E[a[a'/x_a]]$ \\
$E[(\lambda x_b.b) \; v]_b \; \rightarrow E[b[v/x_b]]$ \\
\end{tabular}
\caption{Naive evaluation contexts for interoperation.}
\label{fignai}
\end{figure}

\begin{figure}[htb]
\onehalfspacing
\centering
\begin{tabular}{c}

\end{tabular}
\caption{}
\label{fig}
\end{figure}

The model of computation extends the work of Matthews and Findler \cite{matthews07} and uses the work of Kinghorn \cite{kinghorn07} as a starting point. Matthews and Findler presented \cite{matthews07} two approaches to resolving static and dynamic type systems for interoperation. In the first approach, called lump embedding, languages are tied together by new expressions called boundaries that embed expressions of one language within another, which represent the exchange of the embedded expressions from the inner languages to the outer languages. The embedded expressions, when exchanged, are opaque values that cannot be inspected by the outer language, and can only be returned to the inner language. In the second approach, called natural embedding, languages are tied together as with lump embedding, but instead of opaqueness, embedded expressions are reduced to values, then converted into equal values of the outer language following type annotations in the boundaries. To return a converted value back to the inner language, it must be converted back.

The systems of interoperation presented by Matthews and Findler \cite{matthews07} preserved the equivalence of values converted between languages that have incompatible type systems. Since the languages they used were all eager, there were no evaluation strategy incompatibilities to resolve. If a lazy language is introduced to their systems, then interoperation does not preserve the equivalence of values converted between the lazy language and the eager languages. For example, since the application of a converted function involves applications in both the outer and inner languages, the argument is subject to both the outer and inner evaluation strategies. If the outer language is lazy and the inner language is eager, then the argument may be evaluated by the inner language but not the outer language. In this case, the converted function is not equivalent to the original function. Futhermore, the conversion of composite types like lists from lazy languages to eager ones may diverge or cause an error because eager evaluation will convert the entire value, which may be of infinite size or contain expressions assumed by lazy languages not to be immediately evaluated.

Lazy and eager evaluation take opposite approaches: lazy evaluation evaluates expressions as needed, and eager evaluation evaluates expressions immediately. As such, for common expressions, lazy evaluation evaluates a proper subset of the expressions that eager evaluation does. In other words, the set of lazy evaluation strictness points is a proper subset of that of eager evaluation. The difference between these two sets is the set of incompatible strictness points that may change the meaning of values converted from eager languages to lazy ones or may cause a divergence or an error for values converted from lazy languages to eager ones. Where boundaries that contain expressions of lazy languages are at these points, the original lazy evaluation strategy must be followed, and the guards not evaluated. This requires introducing a dual notion of values where \emph{forced} values force the evaluation of guarded expressions of lazy languages and \emph{unforced} values prevent their evaluation.