\section{Introduction}

Programmers forgo existing solutions to problems in other programming languages where software interoperation proves too cumbersome; they remake solutions, rather than reuse them. To facilitate reuse, interoperation must resolve incompatible language features transparently at the boundaries between languages. To address part of this problem, we present a model of computation that resolves lazy and eager evaluation strategies.

Matthews and Findler presented \cite{matthews07} a model that enabled safe interoperation between statically and dynamically typed languages with parametric and ad-hoc polymorphism, respectively. We extend this model in various ways to demonstrate that it is insufficient to enable safe interoperation between eagerly and lazily evaluated languages, analyze the underlying problem, then introduce changes that resolve the fundamental interoperation incompatibility between eager and lazy languages.

Our model is a strict superset of that of Matthews and Findler. We introduce a third language to the model that is based on Haskell and is identical to the ML model except for having lazy evaluation. To the Haskell and ML models we introduce fixed-point operations to restore Turing completeness, and to every language we introduce lists. Hereafter, we use the names of Haskell, ML, and Scheme to refer to their counterparts in our model.