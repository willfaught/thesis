\section{Introduction}

The complexities of software interoperation in part engender the proverbial reinvention of the wheel. Programmers forgo existing solutions to problems in other languages where interoperation proves too cumbersome; they reimplement software components, rather than reuse them. Disparate programming language features complicate the conversion of values exchanged between components of different languages. Resolving language incompatibilities transparently at boundaries between component languages facilitates reuse by unburdening programmers. To address part of this problem, this paper presents a model of computation that resolves a particular case of incompatible evaluation strategies.

The systems of interoperation presented by Matthews and Findler \cite{matthews07} use call-by-value evaluation strategies that eagerly evaluate expressions. Were a language using a call-by-name evaluation strategy that lazily evaluates expressions introduced to their system, interoperation would change the meaning of values converted between languages. For example, since the application of a converted function involves applications in both the outer and inner languages, the argument is subject to both outer and inner evaluations strategies. If the outer language is lazy and the inner language is eager, the argument may be evaluated by the inner language but not the outer language, thereby violating assumptions about the order of evaluation by the outer language and thus changing the meaning of the function. Futhermore, the conversion of a composite type from a lazy language to an eager language may diverge or cause an error, since the outer language will eagerly convert the entire list, which may diverge or cause an error.

The evaluation of guarded expressions follows the evaluation strategy of the outer language, so where the outer and inner languages have different evaluation strategies, interoperation may change the meaning of values converted from the inner language to the outer language.

Evaluation strategies can differ by the number and positions of their strictness points. Where the strictness points of one evaluation strategy is a proper subset of another, the exclusive disjunction between these two sets is the set of incompatible strictness points that must be resolved for interoperation. For two languages with a non-empty set of incompatible strictness points, where the lazier language is the inner language, 

Where the strictness points of the inner language is a proper subset of those of the outer language, expressions assumed to never be evaluated, or evaluated only a finite number of times, 



For example, recursively-defined data like infinite lists

Since Matthews and Findler used call-by-value evaluation strategies for their ML and Scheme models, it is illustrative to introduce a third language that uses an incompatible evaluation strategy: call-by-name. Thus their model is extended with a third language, identical to the ML model except it uses a call-by-name evaluation strategy, and named after Haskell, to which it is more similar than ML.

Call-by-name and call-by-value evaluation strategies use orders of evaluation that take opposite approaches. Call-by-name evaluates expressions needed only by primitive operations, whereas call-by-value evaluates all expressions. As such, call-by-name evaluates a proper subset of the expressions that call-by-value does. In other words, the set of call-by-name strictness points is a proper subset of that of call-by-value. The exclusive disjunction between these two sets is the set of incompatible strictness points that may change the meaning of values converted from call-by-name languages to call-by-value languages. In call-by-name, expressions at these points may be assumed to never be evaluated, or assumed to be evaluated only a finite number of times. Call-by-value may violate these assumptions.

Interoperation requires preserving these strictness points for each evaluation strategy, even after a call-by-name value is converted to a call-by-value value. For an expression converted by a guard, if its conversion requires it to be evaluated, then the evaluation must follow the order of evaluation defined by the inner language's evaluation strategy. This means deferring the evaluation of converted call-by-name expressions in these incompatible points using a dual notion of values and evaluation contexts in call-by-value languages that handles both call-by-value values and guarded call-by-name expressions, called \emph{forced} and \emph{unforced} values and evaluation contexts.