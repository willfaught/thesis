\section{Introduction}

Programmers forgo existing solutions to problems in other programming languages where software interoperation proves too cumbersome; they remake solutions, rather than reuse them. To facilitate reuse, interoperation must resolve incompatible language features transparently at the boundaries between languages. To address part of this problem, we present a model of computation that resolves lazy and eager evaluation strategies.

Matthews and Findler presented \cite{matthews07} a model that enabled safe interoperation between statically and dynamically typed languages with parametric and ad-hoc polymorphism, respectively. We extend this model in various ways to demonstrate that it is insufficient to enable safe interoperation between eagerly and lazily evaluated languages, analyze the underlying problem, then introduce changes that resolve the fundamental interoperation incompatibility between eager and lazy languages.