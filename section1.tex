\section{Introduction}

Programmers forgo existing solutions to problems in other programming languages where software interoperation proves too cumbersome; they remake solutions, rather than reuse them. To facilitate reuse, interoperation must resolve language incompatibilities transparently. To address part of this problem, we present a model of computation that resolves lazy and eager evaluation strategies.

Matthews and Findler presented a method of safe interoperation between languages with incompatible polymorphic static and dynamic type systems \cite{matthews07}. We observe that their method is insufficient for safe interoperation between languages with incompatible lazy and eager evaluation strategies, then explain the underlying problem, and then finally present a method of interoperation that resolves this incompatibility.

The model of computation of Matthews and Findler comprises two eager languages based on ML and Scheme \cite{matthews07}. We extend their model of computation with a third language that is based on Haskell and identical to their ML-like language, except it is lazy. We introduce lists to all three languages. Hereafter, we use the names of Haskell, ML, and Scheme to refer to their counterparts in our model of computation.

Unlike ML and Scheme, Haskell does not evaluate function arguments or list construction operands. These three contexts comprise the set of incompatible strictness points between Haskell and ML, and Haskell and Scheme. Since Haskell permits unused erroneous or divergent expressions in these contexts and ML and Scheme do not, there are Haskell values that have no counterpart in ML and Scheme. Attempting to convert such values to ML and Scheme forces the evaluation of such expressions and breaks the transparency of interoperation.

Moreover, since the conversion of functions from ML and Scheme to Haskell requires the application of the original function to the converted Haskell argument, ML and Scheme always force the evaluation of the converted Haskell argument, even if it is never used. The application of such converted functions effectively changes the order of evaluation of Haskell and violates the transparency of interoperation. In these contexts in ML and Scheme, reducible expressions in Haskell boundaries must not be evaluated unless used.

Figure \ref{figlistunfixed} demonstrates how a straightforward introduction of Haskell to the model of Matthews and Findler fails for converting a list construction from Haskell to Scheme. The list construction contains non-terminating expressions ($\Omega$, where the subscript denotes $\Omega$'s type), which diverge when Scheme forces them to evaluate. Figure \ref{figlistfixed} demonsrates interoperation correctly deferring the evaluation of the Haskell list construction operands and reducing to a Scheme normal form.

In figure \ref{figfunctionunfixed}, 

\input{figures/figlistunfixed.tex}

\input{figures/figlistfixed.tex}

\input{figures/figfunctionunfixed.tex}

\input{figures/figfunctionfixed.tex}

The interoperation of Haskell and ML posed another problem: the conversion of type abstractions. The application of a converted type abstraction cannot substitute the type argument into the inner language directly, since the inner language has no notion of the types of the outer language.