\section{Introduction}

The complexities of software interoperation in part engender the proverbial reinvention of the wheel. Programmers forgo existing solutions to problems in other programming languages where interoperation proves too cumbersome; they remake solutions, rather than reuse them. To unburden programmers to facilitate reuse, interoperation must resolve incompatible programming language features transparently at the boundaries between languages. To address part of this problem, this paper presents a model of computation that resolves lazy and eager evaluation strategies.

The systems of interoperation presented by Matthews and Findler \cite{matthews07} used call-by-value evaluation strategies that eagerly evaluate expressions. Were a language introduced to their systems that uses a call-by-name evaluation strategy that lazily evaluates expressions, interoperation would change the meaning of values converted between the lazy language and the eager ones. For example, since the application of a converted function involves applications in both the outer and inner languages, the argument is subject to both the outer and inner evaluation strategies. If the outer language is lazy and the inner language is eager, then the argument may be evaluated by the inner language but not the outer language, thereby violating assumptions made by the outer language about the order of evaluation and thus changing the meaning of the original function. Futhermore, the conversion of composite types like lists from lazy languages to eager ones may diverge or cause an error because eager evaluation will convert the entire value, which may be of infinite size or contain expressions assumed by lazy languages not to be immediately evaluated.

Lazy and eager evaluation take opposite approaches: lazy evaluation evaluates expressions as needed, and eager evaluation evaluates all expressions. As such, for common expressions, lazy evaluation evaluates a proper subset of the expressions that eager evaluation does. In other words, the set of lazy evaluation strictness points is a proper subset of that of eager evaluation. The difference between these two sets is the set of incompatible strictness points that may change the meaning of values converted from eager languages to lazy ones or may cause a divergence or an error for values converted from lazy languages to eager ones. Where guarded expressions of lazy languages occur at these points, the original lazy evaluation strategy must be followed, and the guards not evaluated. This requires introducing a dual notion of values where \emph{forced} values force the evaluation of guarded expressions of lazy languages and \emph{unforced} values prevent their evaluation.