\section{Model of Computation}

The model of computation extends the model presented by Kinghorn \cite{kinghorn07} with a third language identical to the ML model except it uses lazy evaluation, and as such is named after Haskell, to which it is more similar. Hereafter, the names Haskell, ML, and Scheme refer to their corresponding models in this paper. Lists are added to all three languages. Being lazy, Haskell does not evaluate function arguments or list construction operands. These three points constitute the set of incompatible strictness points between Haskell and ML and Haskell and Scheme. At these points in ML and Scheme, reducible expressions in Haskell boundaries must not be evaluated.

Since values are irreducible at all points, and since the expressions in Haskell boundaries are irreducible at some points and not others, Haskell boundaries are a new kind of value called an \emph{unforced value}. Like thunks, unforced values can be forced to evaluate to values. The Haskell expressions in Haskell boundaries are forced to evaluate to Haskell values, then the Haskell values are converted to ML or Scheme values. ML and Scheme values are called \emph{forced values} because any might be the result of forcing an unforced value. Forced values are a proper subset of unforced values because unforced values can only be at points where forced values can also be, but forced values can be at points where unforced values cannot. ML and Scheme reduction rules and evaluation contexts use unforced values at the incompatible strictness points to match against Haskell boundaries, and their evaluation contexts prevent evaluation within Haskell boundaries at those points.

Figure \ref{figunf} illustrates forced and unforced values at work for the cases explained in the introduction. The reductions for lines 1-4 show that the outer Haskell argument $zeroes$ is not forced by the application of the inner Scheme function. The reductions for lines 4-8 show that the conversion of $zeroes$ from Haskell to Scheme did not diverge, despite $zeroes$ being a list of infinite size.

\input{figures/unforced.tex}

\begin{theorem}{Evaluation Strategy Preservation}

\label{thmstr}
$\varexph = \expmh{\vartym}{\vartyh}{\varexph} = \expsh{\vartyh}{\varexph}$.
$\varexpm = \exphm{\vartyh}{\vartym}{\varexpm} = \expsm{\vartym}{\varexpm}$.
$\varexps = \exphs{\vartyh}{\varexps} = \expms{\vartym}{\varexps}$.
\begin{proof}
By structural induction.
\end{proof}
\end{theorem}

The interoperation of Haskell and ML posed another problem: the conversion of type abstractions. The application of a converted type abstraction cannot substitute the type argument into the inner language directly, since the inner language has no notion of the types of the outer language. Instead, conversion substitutes lumps in a boundary's inner type. The application of a converted type abstraction substitutes the type argument in the boundary's outer type. Since the natural embedding \cite{matthews07} requires the boundary's outer and inner types to be equal, a new equality relation called lump equality is used here that allows lumps within the boundary's inner type to match any corresponding type in the boundary's outer type.

Legends of symbol and syntax names are presented in figures \ref{figsymbols}-\ref{figsyntax2}; Haskell is presented in figures \ref{fighs}-\ref{fighsos}; ML is presented in figures \ref{figms}-\ref{figmsos}; Scheme is presented in figures \ref{figss}-\ref{figsmos}; the unbrand function is presented in figure \ref{figunbrand}; and the lump equality relation is presented in figure \ref{figequality}.

\clearpage

\input{model/symbols.tex}

\clearpage

\input{model/syntax.tex}

\clearpage

\input{model/haskell/syntax.tex}

\clearpage

\input{model/haskell/typing-rules.tex}

\clearpage

\input{model/haskell/operational-semantics/haskell.tex}

\clearpage

\input{model/haskell/operational-semantics/ml.tex}

\clearpage

\input{model/haskell/operational-semantics/scheme.tex}

\clearpage

\input{model/ml/syntax.tex}

\clearpage

\input{model/ml/typing-rules.tex}

\clearpage

\input{model/ml/operational-semantics/ml.tex}

\clearpage

\input{model/ml/operational-semantics/haskell.tex}

\clearpage

\input{model/ml/operational-semantics/scheme.tex}

\clearpage

\input{model/scheme/syntax.tex}

\clearpage

\input{model/scheme/typing-rules.tex}

\clearpage

\input{model/scheme/operational-semantics/scheme.tex}

\clearpage

\input{model/scheme/operational-semantics/haskell.tex}

\clearpage

\input{model/scheme/operational-semantics/ml.tex}

\clearpage

\input{model/unbrand.tex}

\clearpage

\input{model/equality.tex}

\clearpage