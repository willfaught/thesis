\section{Model of Computation}

The model is a strict superset of that of Matthews and Findler \cite{matthews07}. A third language is introduced to the model that is based on Haskell and is identical to the ML model except it is lazy. To the Haskell and ML models, fixed-point operations are introduced to restore Turing completeness, and lists are introduced to every language. Hereafter, we use the names of Haskell, ML, and Scheme to refer to their counterparts in the model.

Being lazy, Haskell does not evaluate function arguments or list construction operands. These three contexts constitute the set of incompatible strictness points between Haskell and ML, and Haskell and Scheme. In both cases, the eager language forces the evaluation of more expressions than the lazy one, hence the lazy one is less restrictive of the types of well-behaved expressions. Since the conversion of values between languages mirrors the original structure of the values, the eager languages cannot evaluate imported expressions in these contexts because they could in effect change the order of evaluation for those imported expressions from the perspective of the lazy language. In these contexts in ML and Scheme, reducible expressions in Haskell boundaries must not be evaluated.


\input{figures/figfunctionunfixed.tex}

\input{figures/figfunctionfixed.tex}

\input{figures/figlistunfixed.tex}

\input{figures/figlistfixed.tex}

Discuss hs t (sh t e) -> e / hm

Figure ? illustrates forced and unforced values at work for the cases explained in the introduction. The reductions for lines 1-4 show that the outer Haskell argument $zeroes$ is not forced by the application of the inner Scheme function. The reductions for lines 4-8 show that the conversion of $zeroes$ from Haskell to Scheme did not diverge, despite $zeroes$ being a list of infinite size.

\begin{theorem}{Evaluation Strategy Preservation}

TODO: equality used here doesn't match term equality

\label{thmstr}
$\varexph = \expmh{\vartym}{\vartyh}{\varexph} = \expsh{\vartyh}{\varexph}$.
$\varexpm = \exphm{\vartyh}{\vartym}{\varexpm} = \expsm{\vartym}{\varexpm}$.
$\varexps = \exphs{\vartyh}{\varexps} = \expms{\vartym}{\varexps}$.
\begin{proof}
By structural induction.
\end{proof}
\end{theorem}

The interoperation of Haskell and ML posed another problem: the conversion of type abstractions. The application of a converted type abstraction cannot substitute the type argument into the inner language directly, since the inner language has no notion of the types of the outer language. Instead, conversion substitutes lumps in a boundary's inner type. The application of a converted type abstraction substitutes the type argument in the boundary's outer type. Since the natural embedding \cite{matthews07} requires the boundary's outer and inner types to be equal, a new equality relation called lump equality is used here that allows lumps within the boundary's inner type to match any corresponding type in the boundary's outer type.

Legends of symbol and syntax names are presented in figures \ref{figsymbols}-\ref{figsyntax2}; Haskell is presented in figures \ref{fighs}-\ref{fighsos}; ML is presented in figures \ref{figms}-\ref{figmsos}; Scheme is presented in figures \ref{figss}-\ref{figsmos}; the unbrand function is presented in figure \ref{figunbrand}; and the lump equality relation is presented in figure \ref{figequality}.

\clearpage

\input{model/symbols.tex}

\clearpage

\input{model/syntax.tex}

\clearpage

\input{model/haskell/syntax.tex}

\clearpage

\input{model/haskell/typing-rules.tex}

\clearpage

\input{model/haskell/operational-semantics/haskell.tex}

\clearpage

\input{model/haskell/operational-semantics/ml.tex}

\clearpage

\input{model/haskell/operational-semantics/scheme.tex}

\clearpage

\input{model/ml/syntax.tex}

\clearpage

\input{model/ml/typing-rules.tex}

\clearpage

\input{model/ml/operational-semantics/ml.tex}

\clearpage

\input{model/ml/operational-semantics/haskell.tex}

\clearpage

\input{model/ml/operational-semantics/scheme.tex}

\clearpage

\input{model/scheme/syntax.tex}

\clearpage

\input{model/scheme/typing-rules.tex}

\clearpage

\input{model/scheme/operational-semantics/scheme.tex}

\clearpage

\input{model/scheme/operational-semantics/haskell.tex}

\clearpage

\input{model/scheme/operational-semantics/ml.tex}

\clearpage

\input{model/unbrand.tex}

\clearpage

\input{model/equality.tex}

\clearpage