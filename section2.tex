\newcommand{\haskell}{Haskell model\xspace}
\newcommand{\ml}{ML model\xspace}
\newcommand{\scheme}{Scheme model\xspace}

\newcommand{\haskellml}{Haskell and ML models\xspace}
\newcommand{\haskellmlscheme}{Haskell, ML, and Scheme models\xspace}

\newcommand{\articlehaskell}[1]{#1 \haskell}
\newcommand{\articleml}[1]{#1 \ml}
\newcommand{\articlescheme}[1]{#1 \scheme}

\newcommand{\articlehaskellml}[1]{#1 \haskellml}
\newcommand{\articlehaskellmlscheme}[1]{#1 \haskellmlscheme}

\newcommand{\thehaskell}{\articlehaskell{the}}
\newcommand{\Thehaskell}{\articlehaskell{The}}
\newcommand{\theml}{\articleml{the}}
\newcommand{\Theml}{\articleml{The}}
\newcommand{\thescheme}{\articlescheme{the}}
\newcommand{\Thescheme}{\articlescheme{The}}

\newcommand{\thehaskellml}{\articlehaskellml{the}}
\newcommand{\Thehaskellml}{\articlehaskellml{The}}
\newcommand{\thehaskellmlscheme}{\articlehaskellmlscheme{the}}
\newcommand{\Thehaskellmlscheme}{\articlehaskellmlscheme{The}}

\newcommand{\hastype}[1]{has the type #1}
\newcommand{\havetype}[1]{have the type #1}

\section{Model of Computation}

Matthews and Findler used simple languages based on ML and Scheme. To explore and resolve interoperation between lazy and eager evaluation, a third language is introduced that is identical to their ML, except it is lazy instead, and as such is named after Haskell, to which it is more similar.

The model of computation comprises three dependent models of computation, based on that of Matthews and Findler \cite{matthews07}. The Haskell and ML models are based on System F, extended with a fixed-point operation. The Scheme model is based on lambda calculus, having a simple type system to ensure no free variables, and extended with type predicates. All models have natural numbers, arithmetic, conditions, lists, and errors. The Haskell model has a call-by-name evaluation strategy, and ML and Scheme have call-by-value evaluation strategies. The models are presented with grammars and operational semantics in the style of (((CITATION))) and typing rules.

The Haskell model has a (((STRICT?))) subset of the strictness points of the ML and Scheme models, and hence forces the reduction of fewer expressions where those expressions are not used. When a function from the Haskell model is converted to a function in the ML or Scheme models, this same subset must be preserved or the meaning of the function will change and parametricity will not hold. Concretely, this means that function arguments and list construction operands must not be reduced. Thus evaluation contexts for the ML and Scheme models are made aware of whether Haskell language boundary guards are in these places, and if so, to make them irreducible.

Since Haskell language boundary guards are forced in some places but not others, they must be considered a value sometimes, but not others. Thus there are two kinds of values: all values, called unforced values, which include imported Haskell expressions, and forced values, which exclude imported Haskell expressions. Unforced values occur in the evaluation contexts and reduction rules where Haskell importations should not be forced, namely function arguments and list construction operands, and forced values occur everywhere else a value is required.

Evaluation contexts are split into two: forced, \varconf, and unforced, \varconu. Only forced evaluation contexts can reduce anything, including Haskell importations, and unforced evaluation contexts restrict where expressions are forced. Where \varconu appears in an evaluation context, any Haskell importation matching that expression is not forced because only \varconf can reduce it.

Since the Haskell and ML models have their own types, type abstractions from one imported into the other cannot be easily converted, because any type the conversion is applied to cannot be substituted into the other language. Instead, and like the importation of parametric polymorphic types into the Scheme model, the lump type is subsituted into the imported type abstraction, and a lump equality relation, (((LUMP EQUALITY REL))) asserts that corresponding parts of the inner and outer types of the importation must be equal, or one of them must be a lump.

\input{figures/unforced.tex}

\subsection{Notation}

Symbols that represent grammar non-terminals or relations typically have letter subscripts that specify a model.

\Thehaskellml have static type systems that use typing environments, written \env, and typing relations, written \jud. Typing judgements for expressions are written \jude{\env}{\jud}{\varexp}{\varty}, where \varexp is bound in \env and has the type \varty. Typing judgements for types are written \judt{\env}{\jud}{\varty} and mean \varty is bound in \env. Extended typing environments are written \envexte{\env}{\varvar}{\varty} for variables and \envextt{\env}{\tyvar} for type variables. Typing environments are omitted where empty. \Thescheme uses a simple type system to ensure no free variables. Every well-typed \scheme expression \hastype{\tytst}. Type substitution within types is written \tysubst{\formvar{x}}{\formvar{y}}{\formvar{z}}, where the type \formvar{y} is substituted for free occurrences of the type variable \formvar{z} in the type \formvar{x}.

Expression and type substitutions within expressions are written like type substitutions within types.

\clearpage

\input{model/haskell/syntax.tex}

\clearpage

\input{model/haskell/typing-rules.tex}

\clearpage

\input{model/haskell/operational-semantics/haskell.tex}

\clearpage

\input{model/haskell/operational-semantics/ml.tex}

\clearpage

\input{model/haskell/operational-semantics/scheme.tex}

\clearpage

\input{model/ml/syntax.tex}

\clearpage

\input{model/ml/typing-rules.tex}

\clearpage

\input{model/ml/operational-semantics/ml.tex}

\clearpage

\input{model/ml/operational-semantics/haskell.tex}

\clearpage

\input{model/ml/operational-semantics/scheme.tex}

\clearpage

\input{model/scheme/syntax.tex}

\clearpage

\input{model/scheme/typing-rules.tex}

\clearpage

\input{model/scheme/operational-semantics/scheme.tex}

\clearpage

\input{model/scheme/operational-semantics/haskell.tex}

\clearpage

\input{model/scheme/operational-semantics/ml.tex}

\clearpage

\input{model/unbrand.tex}

\clearpage

\input{model/equality.tex}

\clearpage

\input{model/symbols.tex}

\clearpage

\input{model/syntax.tex}

\clearpage