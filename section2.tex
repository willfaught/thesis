\newcommand{\haskell}{Haskell model\xspace}
\newcommand{\ml}{ML model\xspace}
\newcommand{\scheme}{Scheme model\xspace}

\newcommand{\haskellml}{Haskell and ML models\xspace}
\newcommand{\haskellmlscheme}{Haskell, ML, and Scheme models\xspace}

\newcommand{\articlehaskell}[1]{#1 \haskell}
\newcommand{\articleml}[1]{#1 \ml}
\newcommand{\articlescheme}[1]{#1 \scheme}

\newcommand{\articlehaskellml}[1]{#1 \haskellml}
\newcommand{\articlehaskellmlscheme}[1]{#1 \haskellmlscheme}

\newcommand{\thehaskell}{\articlehaskell{the}}
\newcommand{\Thehaskell}{\articlehaskell{The}}
\newcommand{\theml}{\articleml{the}}
\newcommand{\Theml}{\articleml{The}}
\newcommand{\thescheme}{\articlescheme{the}}
\newcommand{\Thescheme}{\articlescheme{The}}

\newcommand{\thehaskellml}{\articlehaskellml{the}}
\newcommand{\Thehaskellml}{\articlehaskellml{The}}
\newcommand{\thehaskellmlscheme}{\articlehaskellmlscheme{the}}
\newcommand{\Thehaskellmlscheme}{\articlehaskellmlscheme{The}}

\newcommand{\hastype}[1]{has the type #1}
\newcommand{\havetype}[1]{have the type #1}

(((TODO: SET DIFFERENCE SHOULD BE FOR ONLY SHARED EXP POSITIONS)))

\section{Model of Computation}

The model of computation extends the model presented by Kinghorn \cite{kinghorn07} with a third language identical to the ML model except it uses lazy evaluation, and as such is named after Haskell, to which it is more similar.

Concretely, this means that function arguments and list construction operands must not be reduced. Thus evaluation contexts for the ML and Scheme models are made aware of whether Haskell language boundary guards are in these places, and if so, to make them irreducible.

Since Haskell language boundary guards are forced in some places but not others, they must be considered a value sometimes, but not others. Thus there are two kinds of values: all values, called unforced values, which include imported Haskell expressions, and forced values, which exclude imported Haskell expressions. Unforced values occur in the evaluation contexts and reduction rules where Haskell importations should not be forced, namely function arguments and list construction operands, and forced values occur everywhere else a value is required.

Evaluation contexts are split into two: forced, \varconf, and unforced, \varconu. Only forced evaluation contexts can reduce anything, including Haskell importations, and unforced evaluation contexts restrict where expressions are forced. Where \varconu appears in an evaluation context, any Haskell importation matching that expression is not forced because only \varconf can reduce it.

Since the Haskell and ML models have their own types, type abstractions from one imported into the other cannot be easily converted, because any type the conversion is applied to cannot be substituted into the other language. Instead, and like the importation of parametric polymorphic types into the Scheme model, the lump type is subsituted into the imported type abstraction, and a lump equality relation, (((LUMP EQUALITY REL))) asserts that corresponding parts of the inner and outer types of the importation must be equal, or one of them must be a lump.

\input{figures/unforced.tex}

\subsection{Notation}

Symbols that represent grammar non-terminals or relations typically have letter subscripts that specify a model.

\Thehaskellml have static type systems that use typing environments, written \env, and typing relations, written \jud. Typing judgements for expressions are written \jude{\env}{\jud}{\varexp}{\varty}, where \varexp is bound in \env and has the type \varty. Typing judgements for types are written \judt{\env}{\jud}{\varty} and mean \varty is bound in \env. Extended typing environments are written \envexte{\env}{\varvar}{\varty} for variables and \envextt{\env}{\tyvar} for type variables. Typing environments are omitted where empty. \Thescheme uses a simple type system to ensure no free variables. Every well-typed \scheme expression \hastype{\tytst}. Type substitution within types is written \tysubst{\formvar{x}}{\formvar{y}}{\formvar{z}}, where the type \formvar{y} is substituted for free occurrences of the type variable \formvar{z} in the type \formvar{x}.

Expression and type substitutions within expressions are written like type substitutions within types.

\clearpage

\input{model/haskell/syntax.tex}

\clearpage

\input{model/haskell/typing-rules.tex}

\clearpage

\input{model/haskell/operational-semantics/haskell.tex}

\clearpage

\input{model/haskell/operational-semantics/ml.tex}

\clearpage

\input{model/haskell/operational-semantics/scheme.tex}

\clearpage

\input{model/ml/syntax.tex}

\clearpage

\input{model/ml/typing-rules.tex}

\clearpage

\input{model/ml/operational-semantics/ml.tex}

\clearpage

\input{model/ml/operational-semantics/haskell.tex}

\clearpage

\input{model/ml/operational-semantics/scheme.tex}

\clearpage

\input{model/scheme/syntax.tex}

\clearpage

\input{model/scheme/typing-rules.tex}

\clearpage

\input{model/scheme/operational-semantics/scheme.tex}

\clearpage

\input{model/scheme/operational-semantics/haskell.tex}

\clearpage

\input{model/scheme/operational-semantics/ml.tex}

\clearpage

\input{model/unbrand.tex}

\clearpage

\input{model/equality.tex}

\clearpage

\input{model/symbols.tex}

\clearpage

\input{model/syntax.tex}

\clearpage