\section{Model of Computation}

The interoperation of Haskell and ML posed another problem: the conversion of type abstractions. The application of a converted type abstraction cannot substitute the type argument into the inner language directly, since the inner language has no notion of the types of the outer language.

Discuss hs t (sh t e) -> e / hm

Figure ? illustrates forced and unforced values at work for the cases explained in the introduction. The reductions for lines 1-4 show that the outer Haskell argument $zeroes$ is not forced by the application of the inner Scheme function. The reductions for lines 4-8 show that the conversion of $zeroes$ from Haskell to Scheme did not diverge, despite $zeroes$ being a list of infinite size.

\begin{theorem}{Evaluation Strategy Preservation}

TODO: equality used here doesn't match term equality

\label{thmstr}
$\varexph = \expmh{\vartym}{\vartyh}{\varexph} = \expsh{\vartyh}{\varexph}$.
$\varexpm = \exphm{\vartyh}{\vartym}{\varexpm} = \expsm{\vartym}{\varexpm}$.
$\varexps = \exphs{\vartyh}{\varexps} = \expms{\vartym}{\varexps}$.
\begin{proof}
By structural induction.
\end{proof}
\end{theorem}

(Lump equality) Instead, conversion substitutes lumps in a boundary's inner type. The application of a converted type abstraction substitutes the type argument in the boundary's outer type. Since the natural embedding \cite{matthews07} requires the boundary's outer and inner types to be equal, a new equality relation called lump equality is used here that allows lumps within the boundary's inner type to match any corresponding type in the boundary's outer type.

Legends of symbol and syntax names are presented in figures \ref{figsymbols}-\ref{figsyntax2}; Haskell is presented in figures \ref{fighs}-\ref{fighsos}; ML is presented in figures \ref{figms}-\ref{figmsos}; Scheme is presented in figures \ref{figss}-\ref{figsmos}; the unbrand function is presented in figure \ref{figunbrand}; and the lump equality relation is presented in figure \ref{figequality}.

\clearpage

\input{model/symbols.tex}

\clearpage

\input{model/syntax.tex}

\clearpage

\input{model/haskell/syntax.tex}

\clearpage

\input{model/haskell/typing-rules.tex}

\clearpage

\input{model/haskell/operational-semantics/haskell.tex}

\clearpage

\input{model/haskell/operational-semantics/ml.tex}

\clearpage

\input{model/haskell/operational-semantics/scheme.tex}

\clearpage

\input{model/ml/syntax.tex}

\clearpage

\input{model/ml/typing-rules.tex}

\clearpage

\input{model/ml/operational-semantics/ml.tex}

\clearpage

\input{model/ml/operational-semantics/haskell.tex}

\clearpage

\input{model/ml/operational-semantics/scheme.tex}

\clearpage

\input{model/scheme/syntax.tex}

\clearpage

\input{model/scheme/typing-rules.tex}

\clearpage

\input{model/scheme/operational-semantics/scheme.tex}

\clearpage

\input{model/scheme/operational-semantics/haskell.tex}

\clearpage

\input{model/scheme/operational-semantics/ml.tex}

\clearpage

\input{model/unbrand.tex}

\clearpage

\input{model/equality.tex}

\clearpage